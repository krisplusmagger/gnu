<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GNU Radio C++ API Reference: gr::block Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="/usr/share/javascript/mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td id="projectalign">
   <div id="projectname">GNU Radio C++ API Reference<span id="projectnumber">&#160;v3.11.0.0git-829-g889721a8</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classgr_1_1block.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classgr_1_1block-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">gr::block Class Reference<div class="ingroups"><a class="el" href="group__block.html">GNU Radio C++ Signal Processing Blocks</a> &raquo; <a class="el" href="group__base__blk.html">Base classes for GR Blocks</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>The abstract base class for all 'terminal' processing blocks.  
 <a href="classgr_1_1block.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gnuradio-runtime_2include_2gnuradio_2block_8h_source.html">gnuradio/block.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aad622109b3f7676df26c6e75dede24ca" id="r_aad622109b3f7676df26c6e75dede24ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aad622109b3f7676df26c6e75dede24ca">work_return_t</a> { <a class="el" href="classgr_1_1block.html#aad622109b3f7676df26c6e75dede24caa8cac307593cf1087803f28eee28ff45a">WORK_CALLED_PRODUCE</a> = -2
, <a class="el" href="classgr_1_1block.html#aad622109b3f7676df26c6e75dede24caa3e2d37c41af566875030fa1376c4203f">WORK_DONE</a> = -1
 }</td></tr>
<tr class="memdesc:aad622109b3f7676df26c6e75dede24ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic return values from general_work.  <a href="classgr_1_1block.html#aad622109b3f7676df26c6e75dede24ca">More...</a><br /></td></tr>
<tr class="separator:aad622109b3f7676df26c6e75dede24ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc40fd4d514724a5446a2b34b2352b4e" id="r_abc40fd4d514724a5446a2b34b2352b4e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4e">tag_propagation_policy_t</a> { <a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4ea2e3b11eb10000e0efab110c31a83e502">TPP_DONT</a> = 0
, <a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4ea5b3fd823d5f918e588008c0bc876e574">TPP_ALL_TO_ALL</a> = 1
, <a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4ea747127b6fb520f34be8ae3f951fdc53c">TPP_ONE_TO_ONE</a> = 2
, <a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4eaadf6e1b257eee0590cc2b26161d08cdc">TPP_CUSTOM</a> = 3
 }</td></tr>
<tr class="memdesc:abc40fd4d514724a5446a2b34b2352b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum to represent different tag propagation policies.  <a href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4e">More...</a><br /></td></tr>
<tr class="separator:abc40fd4d514724a5446a2b34b2352b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7713e4b282e743e8aac3df3c1b68fd6d" id="r_a7713e4b282e743e8aac3df3c1b68fd6d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a7713e4b282e743e8aac3df3c1b68fd6d">~block</a> () override</td></tr>
<tr class="separator:a7713e4b282e743e8aac3df3c1b68fd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bbd70747868454da06ba2049b61a18" id="r_aa1bbd70747868454da06ba2049b61a18"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aa1bbd70747868454da06ba2049b61a18">history</a> () const</td></tr>
<tr class="separator:aa1bbd70747868454da06ba2049b61a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2dac90e45498ad53a19544c01114136" id="r_ac2dac90e45498ad53a19544c01114136"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ac2dac90e45498ad53a19544c01114136">set_history</a> (unsigned <a class="el" href="classgr_1_1block.html#aa1bbd70747868454da06ba2049b61a18">history</a>)</td></tr>
<tr class="separator:ac2dac90e45498ad53a19544c01114136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad5d6e62ea885cb77d19f72451581c2" id="r_acad5d6e62ea885cb77d19f72451581c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#acad5d6e62ea885cb77d19f72451581c2">declare_sample_delay</a> (int which, unsigned delay)</td></tr>
<tr class="separator:acad5d6e62ea885cb77d19f72451581c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7df9d4ebb09530cd3be2ad78da411b4" id="r_aa7df9d4ebb09530cd3be2ad78da411b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aa7df9d4ebb09530cd3be2ad78da411b4">declare_sample_delay</a> (unsigned delay)</td></tr>
<tr class="separator:aa7df9d4ebb09530cd3be2ad78da411b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbdc43bbdf257d22298bf5e68adb875" id="r_a5fbdc43bbdf257d22298bf5e68adb875"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a5fbdc43bbdf257d22298bf5e68adb875">sample_delay</a> (int which) const</td></tr>
<tr class="separator:a5fbdc43bbdf257d22298bf5e68adb875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82ebb52662cf4fa6b1417d3571414da" id="r_ab82ebb52662cf4fa6b1417d3571414da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ab82ebb52662cf4fa6b1417d3571414da">fixed_rate</a> () const</td></tr>
<tr class="memdesc:ab82ebb52662cf4fa6b1417d3571414da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this block has a fixed input to output rate.  <br /></td></tr>
<tr class="separator:ab82ebb52662cf4fa6b1417d3571414da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc118d94944d2ff71e378f807fb8d28" id="r_a5bc118d94944d2ff71e378f807fb8d28"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a5bc118d94944d2ff71e378f807fb8d28">forecast</a> (int noutput_items, <a class="el" href="types_8h.html#ab02d0a829d67d39e3ac3163016d3a8be">gr_vector_int</a> &amp;ninput_items_required)</td></tr>
<tr class="memdesc:a5bc118d94944d2ff71e378f807fb8d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Estimate input requirements given output request.  <br /></td></tr>
<tr class="separator:a5bc118d94944d2ff71e378f807fb8d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a482fb96a3d7343ffdd86a21538c2e5" id="r_a0a482fb96a3d7343ffdd86a21538c2e5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5">general_work</a> (int noutput_items, <a class="el" href="types_8h.html#ab02d0a829d67d39e3ac3163016d3a8be">gr_vector_int</a> &amp;ninput_items, <a class="el" href="types_8h.html#a80a98fdffb55a4616a3078a827898dc1">gr_vector_const_void_star</a> &amp;input_items, <a class="el" href="types_8h.html#a9f99903ecddf0897227ef6e1eeca2106">gr_vector_void_star</a> &amp;output_items)</td></tr>
<tr class="memdesc:a0a482fb96a3d7343ffdd86a21538c2e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute output items from input items  <br /></td></tr>
<tr class="separator:a0a482fb96a3d7343ffdd86a21538c2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f58745d1374b30a7b866406dc97850f" id="r_a7f58745d1374b30a7b866406dc97850f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a7f58745d1374b30a7b866406dc97850f">start</a> ()</td></tr>
<tr class="memdesc:a7f58745d1374b30a7b866406dc97850f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to enable drivers, etc for i/o devices.  <br /></td></tr>
<tr class="separator:a7f58745d1374b30a7b866406dc97850f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0863bc16f7c84adf4cddf5d53124450e" id="r_a0863bc16f7c84adf4cddf5d53124450e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a0863bc16f7c84adf4cddf5d53124450e">stop</a> ()</td></tr>
<tr class="memdesc:a0863bc16f7c84adf4cddf5d53124450e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to disable drivers, etc for i/o devices.  <br /></td></tr>
<tr class="separator:a0863bc16f7c84adf4cddf5d53124450e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d67fd758b70c6f2d7b7d4edcec53b3" id="r_a63d67fd758b70c6f2d7b7d4edcec53b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a63d67fd758b70c6f2d7b7d4edcec53b3">set_output_multiple</a> (int multiple)</td></tr>
<tr class="memdesc:a63d67fd758b70c6f2d7b7d4edcec53b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrain the noutput_items argument passed to forecast and general_work.  <br /></td></tr>
<tr class="separator:a63d67fd758b70c6f2d7b7d4edcec53b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a78a1ee7447a340162c719ef948b915" id="r_a9a78a1ee7447a340162c719ef948b915"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a9a78a1ee7447a340162c719ef948b915">output_multiple</a> () const</td></tr>
<tr class="separator:a9a78a1ee7447a340162c719ef948b915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c6867e113ea236e5e07a3674783e1d" id="r_ad3c6867e113ea236e5e07a3674783e1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ad3c6867e113ea236e5e07a3674783e1d">output_multiple_set</a> () const</td></tr>
<tr class="separator:ad3c6867e113ea236e5e07a3674783e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b49c097bffefe79f9d730539330edf" id="r_a49b49c097bffefe79f9d730539330edf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a49b49c097bffefe79f9d730539330edf">set_alignment</a> (int multiple)</td></tr>
<tr class="memdesc:a49b49c097bffefe79f9d730539330edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constrains buffers to work on a set item alignment (for SIMD)  <br /></td></tr>
<tr class="separator:a49b49c097bffefe79f9d730539330edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e9110914ad00e6d8b9b9e4837508c4" id="r_a97e9110914ad00e6d8b9b9e4837508c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a97e9110914ad00e6d8b9b9e4837508c4">alignment</a> () const</td></tr>
<tr class="separator:a97e9110914ad00e6d8b9b9e4837508c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d914fbc7814a682e25f5b2a40140d47" id="r_a4d914fbc7814a682e25f5b2a40140d47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a4d914fbc7814a682e25f5b2a40140d47">set_unaligned</a> (int na)</td></tr>
<tr class="separator:a4d914fbc7814a682e25f5b2a40140d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079b46fddc4241f7d5784f47a4d69893" id="r_a079b46fddc4241f7d5784f47a4d69893"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a079b46fddc4241f7d5784f47a4d69893">unaligned</a> () const</td></tr>
<tr class="separator:a079b46fddc4241f7d5784f47a4d69893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d33c4cc8b0131b9b8df41e3b46784b1" id="r_a0d33c4cc8b0131b9b8df41e3b46784b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a0d33c4cc8b0131b9b8df41e3b46784b1">set_is_unaligned</a> (bool u)</td></tr>
<tr class="separator:a0d33c4cc8b0131b9b8df41e3b46784b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6323c615066d53d4d1b374900abb3f3" id="r_aa6323c615066d53d4d1b374900abb3f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aa6323c615066d53d4d1b374900abb3f3">is_unaligned</a> () const</td></tr>
<tr class="separator:aa6323c615066d53d4d1b374900abb3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47193333ce3fe1536fb1663bf314f63d" id="r_a47193333ce3fe1536fb1663bf314f63d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a47193333ce3fe1536fb1663bf314f63d">consume</a> (int which_input, int how_many_items)</td></tr>
<tr class="memdesc:a47193333ce3fe1536fb1663bf314f63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the scheduler <code>how_many_items</code> of input stream <code>which_input</code> were consumed.  <br /></td></tr>
<tr class="separator:a47193333ce3fe1536fb1663bf314f63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ea5eba701e22a3d023d0ba7c6ee07c" id="r_a12ea5eba701e22a3d023d0ba7c6ee07c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a12ea5eba701e22a3d023d0ba7c6ee07c">consume_each</a> (int how_many_items)</td></tr>
<tr class="memdesc:a12ea5eba701e22a3d023d0ba7c6ee07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the scheduler <code>how_many_items</code> were consumed on each input stream.  <br /></td></tr>
<tr class="separator:a12ea5eba701e22a3d023d0ba7c6ee07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5581727d057bdd8113f8b2a3fc5bd66" id="r_aa5581727d057bdd8113f8b2a3fc5bd66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aa5581727d057bdd8113f8b2a3fc5bd66">produce</a> (int which_output, int how_many_items)</td></tr>
<tr class="memdesc:aa5581727d057bdd8113f8b2a3fc5bd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell the scheduler <code>how_many_items</code> were produced on output stream <code>which_output</code>.  <br /></td></tr>
<tr class="separator:aa5581727d057bdd8113f8b2a3fc5bd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3003eea3517dd3e8d9a5297c1196b1" id="r_aff3003eea3517dd3e8d9a5297c1196b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aff3003eea3517dd3e8d9a5297c1196b1">set_relative_rate</a> (double <a class="el" href="classgr_1_1block.html#a2a9a0d39af4c22733092d6556042e810">relative_rate</a>)</td></tr>
<tr class="memdesc:aff3003eea3517dd3e8d9a5297c1196b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the approximate output rate / input rate.  <br /></td></tr>
<tr class="separator:aff3003eea3517dd3e8d9a5297c1196b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbfba0f5144d425430e4139520bb297" id="r_a2cbfba0f5144d425430e4139520bb297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a2cbfba0f5144d425430e4139520bb297">set_inverse_relative_rate</a> (double inverse_relative_rate)</td></tr>
<tr class="memdesc:a2cbfba0f5144d425430e4139520bb297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the approximate output rate / input rate using its reciprocal.  <br /></td></tr>
<tr class="separator:a2cbfba0f5144d425430e4139520bb297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7794aa6f7ae1f9e243d6bc07687a77" id="r_adf7794aa6f7ae1f9e243d6bc07687a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#adf7794aa6f7ae1f9e243d6bc07687a77">set_relative_rate</a> (uint64_t interpolation, uint64_t decimation)</td></tr>
<tr class="memdesc:adf7794aa6f7ae1f9e243d6bc07687a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the approximate output rate / input rate as an integer ratio.  <br /></td></tr>
<tr class="separator:adf7794aa6f7ae1f9e243d6bc07687a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a9a0d39af4c22733092d6556042e810" id="r_a2a9a0d39af4c22733092d6556042e810"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a2a9a0d39af4c22733092d6556042e810">relative_rate</a> () const</td></tr>
<tr class="memdesc:a2a9a0d39af4c22733092d6556042e810"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the approximate output rate / input rate  <br /></td></tr>
<tr class="separator:a2a9a0d39af4c22733092d6556042e810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a82fc4f09727a83d21a491dc355db4" id="r_aa6a82fc4f09727a83d21a491dc355db4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aa6a82fc4f09727a83d21a491dc355db4">relative_rate_i</a> () const</td></tr>
<tr class="memdesc:aa6a82fc4f09727a83d21a491dc355db4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the numerator, or interpolation rate, of the approximate output rate / input rate  <br /></td></tr>
<tr class="separator:aa6a82fc4f09727a83d21a491dc355db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691c55aa7b05a6b316754b4833c7c08b" id="r_a691c55aa7b05a6b316754b4833c7c08b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a691c55aa7b05a6b316754b4833c7c08b">relative_rate_d</a> () const</td></tr>
<tr class="memdesc:a691c55aa7b05a6b316754b4833c7c08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the denominator, or decimation rate, of the approximate output rate / input rate  <br /></td></tr>
<tr class="separator:a691c55aa7b05a6b316754b4833c7c08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594fc8f2ff2e456ed929221437696bce" id="r_a594fc8f2ff2e456ed929221437696bce"><td class="memItemLeft" align="right" valign="top">mpq_class &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a594fc8f2ff2e456ed929221437696bce">mp_relative_rate</a> ()</td></tr>
<tr class="memdesc:a594fc8f2ff2e456ed929221437696bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the multiple precision rational representation of the approximate output rate / input rate  <br /></td></tr>
<tr class="separator:a594fc8f2ff2e456ed929221437696bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e37b19dd73c24113ca9b848db00d16" id="r_a95e37b19dd73c24113ca9b848db00d16"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a95e37b19dd73c24113ca9b848db00d16">fixed_rate_ninput_to_noutput</a> (int ninput)</td></tr>
<tr class="memdesc:a95e37b19dd73c24113ca9b848db00d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given ninput samples, return number of output samples that will be produced. N.B. this is only defined if fixed_rate returns true. Generally speaking, you don't need to override this.  <br /></td></tr>
<tr class="separator:a95e37b19dd73c24113ca9b848db00d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe37ff91774ef438bdfcddd0a47ec1a6" id="r_abe37ff91774ef438bdfcddd0a47ec1a6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#abe37ff91774ef438bdfcddd0a47ec1a6">fixed_rate_noutput_to_ninput</a> (int noutput)</td></tr>
<tr class="memdesc:abe37ff91774ef438bdfcddd0a47ec1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given noutput samples, return number of input samples required to produce noutput. N.B. this is only defined if fixed_rate returns true. Generally speaking, you don't need to override this.  <br /></td></tr>
<tr class="separator:abe37ff91774ef438bdfcddd0a47ec1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2279d1eb421203bc5b0f100a6d5dc263" id="r_a2279d1eb421203bc5b0f100a6d5dc263"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a2279d1eb421203bc5b0f100a6d5dc263">nitems_read</a> (unsigned int which_input)</td></tr>
<tr class="memdesc:a2279d1eb421203bc5b0f100a6d5dc263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items read on input stream which_input.  <br /></td></tr>
<tr class="separator:a2279d1eb421203bc5b0f100a6d5dc263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742128a481fcb9e43a3e0cd535a57f9e" id="r_a742128a481fcb9e43a3e0cd535a57f9e"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a742128a481fcb9e43a3e0cd535a57f9e">nitems_written</a> (unsigned int which_output)</td></tr>
<tr class="memdesc:a742128a481fcb9e43a3e0cd535a57f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of items written on output stream which_output.  <br /></td></tr>
<tr class="separator:a742128a481fcb9e43a3e0cd535a57f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4892196a19ef044a0eedeaa6566893c8" id="r_a4892196a19ef044a0eedeaa6566893c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4e">tag_propagation_policy_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a4892196a19ef044a0eedeaa6566893c8">tag_propagation_policy</a> ()</td></tr>
<tr class="memdesc:a4892196a19ef044a0eedeaa6566893c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asks for the policy used by the scheduler to moved tags downstream.  <br /></td></tr>
<tr class="separator:a4892196a19ef044a0eedeaa6566893c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476e218927e426ac88c26431cbf086cd" id="r_a476e218927e426ac88c26431cbf086cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a476e218927e426ac88c26431cbf086cd">set_tag_propagation_policy</a> (<a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4e">tag_propagation_policy_t</a> p)</td></tr>
<tr class="memdesc:a476e218927e426ac88c26431cbf086cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the policy by the scheduler to determine how tags are moved downstream.  <br /></td></tr>
<tr class="separator:a476e218927e426ac88c26431cbf086cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90ff4303cdcd140143b4f9f55a441ee" id="r_ab90ff4303cdcd140143b4f9f55a441ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ab90ff4303cdcd140143b4f9f55a441ee">min_noutput_items</a> () const</td></tr>
<tr class="memdesc:ab90ff4303cdcd140143b4f9f55a441ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the minimum number of output items this block can produce during a call to work.  <br /></td></tr>
<tr class="separator:ab90ff4303cdcd140143b4f9f55a441ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cfc579150dc4d10c6180d3365aa9a8" id="r_a65cfc579150dc4d10c6180d3365aa9a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a65cfc579150dc4d10c6180d3365aa9a8">set_min_noutput_items</a> (int m)</td></tr>
<tr class="memdesc:a65cfc579150dc4d10c6180d3365aa9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the minimum number of output items this block can produce during a call to work.  <br /></td></tr>
<tr class="separator:a65cfc579150dc4d10c6180d3365aa9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af710a90819f19705f2d2ba1aa49d0172" id="r_af710a90819f19705f2d2ba1aa49d0172"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#af710a90819f19705f2d2ba1aa49d0172">max_noutput_items</a> ()</td></tr>
<tr class="memdesc:af710a90819f19705f2d2ba1aa49d0172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of output items this block will handle during a call to work.  <br /></td></tr>
<tr class="separator:af710a90819f19705f2d2ba1aa49d0172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2405dc2f6c84bb8e59aab56e4ce9d84" id="r_ae2405dc2f6c84bb8e59aab56e4ce9d84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ae2405dc2f6c84bb8e59aab56e4ce9d84">set_max_noutput_items</a> (int m)</td></tr>
<tr class="memdesc:ae2405dc2f6c84bb8e59aab56e4ce9d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of output items this block will handle during a call to work.  <br /></td></tr>
<tr class="separator:ae2405dc2f6c84bb8e59aab56e4ce9d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460e8e5f15a4c5418ce3fc167c20a973" id="r_a460e8e5f15a4c5418ce3fc167c20a973"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a460e8e5f15a4c5418ce3fc167c20a973">unset_max_noutput_items</a> ()</td></tr>
<tr class="memdesc:a460e8e5f15a4c5418ce3fc167c20a973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the switch for using the max_noutput_items value of this block.  <br /></td></tr>
<tr class="separator:a460e8e5f15a4c5418ce3fc167c20a973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f67d984bc126aa4d254e62464525b79" id="r_a4f67d984bc126aa4d254e62464525b79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a4f67d984bc126aa4d254e62464525b79">is_set_max_noutput_items</a> ()</td></tr>
<tr class="memdesc:a4f67d984bc126aa4d254e62464525b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the block if the flag is or is not set to use the internal value of max_noutput_items during a call to work.  <br /></td></tr>
<tr class="separator:a4f67d984bc126aa4d254e62464525b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbf96f6a81d5c289934a68ef44dd1b4" id="r_a9bbf96f6a81d5c289934a68ef44dd1b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a9bbf96f6a81d5c289934a68ef44dd1b4">expand_minmax_buffer</a> (int port)</td></tr>
<tr class="separator:a9bbf96f6a81d5c289934a68ef44dd1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faeaab35423014dc59749d63cfe4cf1" id="r_a5faeaab35423014dc59749d63cfe4cf1"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a5faeaab35423014dc59749d63cfe4cf1">max_output_buffer</a> (size_t i)</td></tr>
<tr class="memdesc:a5faeaab35423014dc59749d63cfe4cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns max buffer size on output port <code>i</code>.  <br /></td></tr>
<tr class="separator:a5faeaab35423014dc59749d63cfe4cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711fb69e35fb871e9a5e41d6a1f2afb1" id="r_a711fb69e35fb871e9a5e41d6a1f2afb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a711fb69e35fb871e9a5e41d6a1f2afb1">set_max_output_buffer</a> (long <a class="el" href="classgr_1_1block.html#a5faeaab35423014dc59749d63cfe4cf1">max_output_buffer</a>)</td></tr>
<tr class="memdesc:a711fb69e35fb871e9a5e41d6a1f2afb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request limit on max buffer size on all output ports.  <br /></td></tr>
<tr class="separator:a711fb69e35fb871e9a5e41d6a1f2afb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d021628c08db3b138d3ee7c572ad90" id="r_a96d021628c08db3b138d3ee7c572ad90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a96d021628c08db3b138d3ee7c572ad90">set_max_output_buffer</a> (int port, long <a class="el" href="classgr_1_1block.html#a5faeaab35423014dc59749d63cfe4cf1">max_output_buffer</a>)</td></tr>
<tr class="memdesc:a96d021628c08db3b138d3ee7c572ad90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request limit on max buffer size on output port <code>port</code>.  <br /></td></tr>
<tr class="separator:a96d021628c08db3b138d3ee7c572ad90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28e42e36ef843b999cca3702981ccd7" id="r_ac28e42e36ef843b999cca3702981ccd7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ac28e42e36ef843b999cca3702981ccd7">min_output_buffer</a> (size_t i)</td></tr>
<tr class="memdesc:ac28e42e36ef843b999cca3702981ccd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns min buffer size on output port <code>i</code>.  <br /></td></tr>
<tr class="separator:ac28e42e36ef843b999cca3702981ccd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d10e3f6747f91b215abe81b60a003d5" id="r_a9d10e3f6747f91b215abe81b60a003d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a9d10e3f6747f91b215abe81b60a003d5">set_min_output_buffer</a> (long <a class="el" href="classgr_1_1block.html#ac28e42e36ef843b999cca3702981ccd7">min_output_buffer</a>)</td></tr>
<tr class="memdesc:a9d10e3f6747f91b215abe81b60a003d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request limit on the minimum buffer size on all output ports.  <br /></td></tr>
<tr class="separator:a9d10e3f6747f91b215abe81b60a003d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a03397c78096a2f1c7f1b59f225f5b" id="r_a46a03397c78096a2f1c7f1b59f225f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a46a03397c78096a2f1c7f1b59f225f5b">set_min_output_buffer</a> (int port, long <a class="el" href="classgr_1_1block.html#ac28e42e36ef843b999cca3702981ccd7">min_output_buffer</a>)</td></tr>
<tr class="memdesc:a46a03397c78096a2f1c7f1b59f225f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request limit on min buffer size on output port <code>port</code>.  <br /></td></tr>
<tr class="separator:a46a03397c78096a2f1c7f1b59f225f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9220cdf7a9972db81549e0ee1bb275" id="r_abc9220cdf7a9972db81549e0ee1bb275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#abc9220cdf7a9972db81549e0ee1bb275">set_blkd_input_timer_value</a> (unsigned int timer_value_ms)</td></tr>
<tr class="memdesc:abc9220cdf7a9972db81549e0ee1bb275"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Configure the timer set when input is blocked <code>port</code>.  <br /></td></tr>
<tr class="separator:abc9220cdf7a9972db81549e0ee1bb275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b0ee4b7eb7b8d334be0125e8464a71" id="r_a37b0ee4b7eb7b8d334be0125e8464a71"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a37b0ee4b7eb7b8d334be0125e8464a71">blkd_input_timer_value</a> ()</td></tr>
<tr class="memdesc:a37b0ee4b7eb7b8d334be0125e8464a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED Returns timer value set when input is blocked.  <br /></td></tr>
<tr class="separator:a37b0ee4b7eb7b8d334be0125e8464a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d5b375cade3fc372f620ca7cfb939b" id="r_a43d5b375cade3fc372f620ca7cfb939b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a43d5b375cade3fc372f620ca7cfb939b">allocate_detail</a> (int ninputs, int noutputs, const std::vector&lt; int &gt; &amp;downstream_max_nitems_vec, const std::vector&lt; uint64_t &gt; &amp;downstream_lcm_nitems_vec, const std::vector&lt; uint32_t &gt; &amp;downstream_max_out_mult_vec)</td></tr>
<tr class="memdesc:a43d5b375cade3fc372f620ca7cfb939b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the <a class="el" href="classgr_1_1block__detail.html" title="Implementation details to support the signal processing abstraction.">block_detail</a> and necessary output buffers for this block.  <br /></td></tr>
<tr class="separator:a43d5b375cade3fc372f620ca7cfb939b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13425cc28b7c19d8e6b004cf15df4063" id="r_a13425cc28b7c19d8e6b004cf15df4063"><td class="memItemLeft" align="right" valign="top">buffer_sptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a13425cc28b7c19d8e6b004cf15df4063">replace_buffer</a> (size_t src_port, size_t dst_port, block_sptr block_owner)</td></tr>
<tr class="memdesc:a13425cc28b7c19d8e6b004cf15df4063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the block's buffer with a new one owned by the block_owner parameter.  <br /></td></tr>
<tr class="separator:a13425cc28b7c19d8e6b004cf15df4063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a03de0d6609ca0e03b875250b7650c" id="r_af4a03de0d6609ca0e03b875250b7650c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#af4a03de0d6609ca0e03b875250b7650c">pc_noutput_items</a> ()</td></tr>
<tr class="memdesc:af4a03de0d6609ca0e03b875250b7650c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets instantaneous noutput_items performance counter.  <br /></td></tr>
<tr class="separator:af4a03de0d6609ca0e03b875250b7650c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3beb47de467a4a117b0c096f8511d3af" id="r_a3beb47de467a4a117b0c096f8511d3af"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a3beb47de467a4a117b0c096f8511d3af">pc_noutput_items_avg</a> ()</td></tr>
<tr class="memdesc:a3beb47de467a4a117b0c096f8511d3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets average noutput_items performance counter.  <br /></td></tr>
<tr class="separator:a3beb47de467a4a117b0c096f8511d3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0725cd4ff4f5040a513c2a61355d434" id="r_ae0725cd4ff4f5040a513c2a61355d434"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ae0725cd4ff4f5040a513c2a61355d434">pc_noutput_items_var</a> ()</td></tr>
<tr class="memdesc:ae0725cd4ff4f5040a513c2a61355d434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets variance of noutput_items performance counter.  <br /></td></tr>
<tr class="separator:ae0725cd4ff4f5040a513c2a61355d434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ef5905d40b507a2230c996d8857289" id="r_a84ef5905d40b507a2230c996d8857289"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a84ef5905d40b507a2230c996d8857289">pc_nproduced</a> ()</td></tr>
<tr class="memdesc:a84ef5905d40b507a2230c996d8857289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets instantaneous num items produced performance counter.  <br /></td></tr>
<tr class="separator:a84ef5905d40b507a2230c996d8857289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b4960e100a088caefa99fb39f99a02" id="r_ad0b4960e100a088caefa99fb39f99a02"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ad0b4960e100a088caefa99fb39f99a02">pc_nproduced_avg</a> ()</td></tr>
<tr class="memdesc:ad0b4960e100a088caefa99fb39f99a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets average num items produced performance counter.  <br /></td></tr>
<tr class="separator:ad0b4960e100a088caefa99fb39f99a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a506f34b8b8c3f968dc0a8cb9da0650" id="r_a1a506f34b8b8c3f968dc0a8cb9da0650"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a1a506f34b8b8c3f968dc0a8cb9da0650">pc_nproduced_var</a> ()</td></tr>
<tr class="memdesc:a1a506f34b8b8c3f968dc0a8cb9da0650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets variance of num items produced performance counter.  <br /></td></tr>
<tr class="separator:a1a506f34b8b8c3f968dc0a8cb9da0650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4989096e4edf5e8171b65e3ce663af1e" id="r_a4989096e4edf5e8171b65e3ce663af1e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a4989096e4edf5e8171b65e3ce663af1e">pc_input_buffers_full</a> (int which)</td></tr>
<tr class="memdesc:a4989096e4edf5e8171b65e3ce663af1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets instantaneous fullness of <code>which</code> input buffer.  <br /></td></tr>
<tr class="separator:a4989096e4edf5e8171b65e3ce663af1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e5deef4ebd0e6c2e11b839eaeadd9f" id="r_a08e5deef4ebd0e6c2e11b839eaeadd9f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a08e5deef4ebd0e6c2e11b839eaeadd9f">pc_input_buffers_full_avg</a> (int which)</td></tr>
<tr class="memdesc:a08e5deef4ebd0e6c2e11b839eaeadd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets average fullness of <code>which</code> input buffer.  <br /></td></tr>
<tr class="separator:a08e5deef4ebd0e6c2e11b839eaeadd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00723a35c6e095da35608c8438e16cdf" id="r_a00723a35c6e095da35608c8438e16cdf"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a00723a35c6e095da35608c8438e16cdf">pc_input_buffers_full_var</a> (int which)</td></tr>
<tr class="memdesc:a00723a35c6e095da35608c8438e16cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets variance of fullness of <code>which</code> input buffer.  <br /></td></tr>
<tr class="separator:a00723a35c6e095da35608c8438e16cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d830331a4274ff8060fa925262afcf" id="r_a97d830331a4274ff8060fa925262afcf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a97d830331a4274ff8060fa925262afcf">pc_input_buffers_full</a> ()</td></tr>
<tr class="memdesc:a97d830331a4274ff8060fa925262afcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets instantaneous fullness of all input buffers.  <br /></td></tr>
<tr class="separator:a97d830331a4274ff8060fa925262afcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d364bfc03abaa13f77b515169a86cb1" id="r_a4d364bfc03abaa13f77b515169a86cb1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a4d364bfc03abaa13f77b515169a86cb1">pc_input_buffers_full_avg</a> ()</td></tr>
<tr class="memdesc:a4d364bfc03abaa13f77b515169a86cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets average fullness of all input buffers.  <br /></td></tr>
<tr class="separator:a4d364bfc03abaa13f77b515169a86cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4a47800f4d1484e276778a2461ce37" id="r_aee4a47800f4d1484e276778a2461ce37"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aee4a47800f4d1484e276778a2461ce37">pc_input_buffers_full_var</a> ()</td></tr>
<tr class="memdesc:aee4a47800f4d1484e276778a2461ce37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets variance of fullness of all input buffers.  <br /></td></tr>
<tr class="separator:aee4a47800f4d1484e276778a2461ce37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab125047ee56cf687e3475674a28d267f" id="r_ab125047ee56cf687e3475674a28d267f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ab125047ee56cf687e3475674a28d267f">pc_output_buffers_full</a> (int which)</td></tr>
<tr class="memdesc:ab125047ee56cf687e3475674a28d267f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets instantaneous fullness of <code>which</code> output buffer.  <br /></td></tr>
<tr class="separator:ab125047ee56cf687e3475674a28d267f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed8f2224fe1d0b27e17cd66723452a8" id="r_a0ed8f2224fe1d0b27e17cd66723452a8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a0ed8f2224fe1d0b27e17cd66723452a8">pc_output_buffers_full_avg</a> (int which)</td></tr>
<tr class="memdesc:a0ed8f2224fe1d0b27e17cd66723452a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets average fullness of <code>which</code> output buffer.  <br /></td></tr>
<tr class="separator:a0ed8f2224fe1d0b27e17cd66723452a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad2a99ea794d44956d2878471e5976d" id="r_a2ad2a99ea794d44956d2878471e5976d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a2ad2a99ea794d44956d2878471e5976d">pc_output_buffers_full_var</a> (int which)</td></tr>
<tr class="memdesc:a2ad2a99ea794d44956d2878471e5976d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets variance of fullness of <code>which</code> output buffer.  <br /></td></tr>
<tr class="separator:a2ad2a99ea794d44956d2878471e5976d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0ec64aeeb1e51206049f7804f7774f" id="r_abc0ec64aeeb1e51206049f7804f7774f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#abc0ec64aeeb1e51206049f7804f7774f">pc_output_buffers_full</a> ()</td></tr>
<tr class="memdesc:abc0ec64aeeb1e51206049f7804f7774f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets instantaneous fullness of all output buffers.  <br /></td></tr>
<tr class="separator:abc0ec64aeeb1e51206049f7804f7774f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f7e6fbb500e78493bc27b85e6c4c9f" id="r_ad7f7e6fbb500e78493bc27b85e6c4c9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ad7f7e6fbb500e78493bc27b85e6c4c9f">pc_output_buffers_full_avg</a> ()</td></tr>
<tr class="memdesc:ad7f7e6fbb500e78493bc27b85e6c4c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets average fullness of all output buffers.  <br /></td></tr>
<tr class="separator:ad7f7e6fbb500e78493bc27b85e6c4c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ecae35f34a1fc99d1bcbdccb844505" id="r_a43ecae35f34a1fc99d1bcbdccb844505"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a43ecae35f34a1fc99d1bcbdccb844505">pc_output_buffers_full_var</a> ()</td></tr>
<tr class="memdesc:a43ecae35f34a1fc99d1bcbdccb844505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets variance of fullness of all output buffers.  <br /></td></tr>
<tr class="separator:a43ecae35f34a1fc99d1bcbdccb844505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b89079d24a3216eb1b17d75ec5b8d8" id="r_ae8b89079d24a3216eb1b17d75ec5b8d8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ae8b89079d24a3216eb1b17d75ec5b8d8">pc_work_time</a> ()</td></tr>
<tr class="memdesc:ae8b89079d24a3216eb1b17d75ec5b8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets instantaneous clock cycles spent in work.  <br /></td></tr>
<tr class="separator:ae8b89079d24a3216eb1b17d75ec5b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df6452cef2999e1b32458a5e542f948" id="r_a2df6452cef2999e1b32458a5e542f948"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a2df6452cef2999e1b32458a5e542f948">pc_work_time_avg</a> ()</td></tr>
<tr class="memdesc:a2df6452cef2999e1b32458a5e542f948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets average clock cycles spent in work.  <br /></td></tr>
<tr class="separator:a2df6452cef2999e1b32458a5e542f948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4918e75c4d11a0b7222c9ba250313ebc" id="r_a4918e75c4d11a0b7222c9ba250313ebc"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a4918e75c4d11a0b7222c9ba250313ebc">pc_work_time_var</a> ()</td></tr>
<tr class="memdesc:a4918e75c4d11a0b7222c9ba250313ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets average clock cycles spent in work.  <br /></td></tr>
<tr class="separator:a4918e75c4d11a0b7222c9ba250313ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9fdd36be297e4b503ccd6290663367" id="r_a2c9fdd36be297e4b503ccd6290663367"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a2c9fdd36be297e4b503ccd6290663367">pc_work_time_total</a> ()</td></tr>
<tr class="memdesc:a2c9fdd36be297e4b503ccd6290663367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets total clock cycles spent in work.  <br /></td></tr>
<tr class="separator:a2c9fdd36be297e4b503ccd6290663367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a27917edcd3b32f10b2166f3362a68" id="r_a78a27917edcd3b32f10b2166f3362a68"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a78a27917edcd3b32f10b2166f3362a68">pc_throughput_avg</a> ()</td></tr>
<tr class="memdesc:a78a27917edcd3b32f10b2166f3362a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets average throughput.  <br /></td></tr>
<tr class="separator:a78a27917edcd3b32f10b2166f3362a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2d3602fe818cef1978090923667009" id="r_adb2d3602fe818cef1978090923667009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#adb2d3602fe818cef1978090923667009">reset_perf_counters</a> ()</td></tr>
<tr class="memdesc:adb2d3602fe818cef1978090923667009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the performance counters.  <br /></td></tr>
<tr class="separator:adb2d3602fe818cef1978090923667009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9425064fac92607770042f472e140d7e" id="r_a9425064fac92607770042f472e140d7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a9425064fac92607770042f472e140d7e">setup_pc_rpc</a> ()</td></tr>
<tr class="memdesc:a9425064fac92607770042f472e140d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up export of perf. counters to ControlPort. Only called by the scheduler.  <br /></td></tr>
<tr class="separator:a9425064fac92607770042f472e140d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6cf687db7ff69169d7fb7e3e346d65" id="r_abf6cf687db7ff69169d7fb7e3e346d65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#abf6cf687db7ff69169d7fb7e3e346d65">is_pc_rpc_set</a> () const</td></tr>
<tr class="memdesc:abf6cf687db7ff69169d7fb7e3e346d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if this block is already exporting perf. counters to ControlPort.  <br /></td></tr>
<tr class="separator:abf6cf687db7ff69169d7fb7e3e346d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74745ea741b0aae938b003854f6043e0" id="r_a74745ea741b0aae938b003854f6043e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a74745ea741b0aae938b003854f6043e0">no_pc_rpc</a> ()</td></tr>
<tr class="memdesc:a74745ea741b0aae938b003854f6043e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the block calls this in its constructor, it's perf. counters will not be exported.  <br /></td></tr>
<tr class="separator:a74745ea741b0aae938b003854f6043e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00276b0a919a51d9255131c92ed91b27" id="r_a00276b0a919a51d9255131c92ed91b27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a00276b0a919a51d9255131c92ed91b27">set_processor_affinity</a> (const std::vector&lt; int &gt; &amp;mask) override</td></tr>
<tr class="memdesc:a00276b0a919a51d9255131c92ed91b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the thread's affinity to processor core <code>n</code>.  <br /></td></tr>
<tr class="separator:a00276b0a919a51d9255131c92ed91b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b99b697f5323c8c062ff6ac5691fc3" id="r_a84b99b697f5323c8c062ff6ac5691fc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a84b99b697f5323c8c062ff6ac5691fc3">unset_processor_affinity</a> () override</td></tr>
<tr class="memdesc:a84b99b697f5323c8c062ff6ac5691fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove processor affinity to a specific core.  <br /></td></tr>
<tr class="separator:a84b99b697f5323c8c062ff6ac5691fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10e476b727d19dc6f95cb2326193607" id="r_aa10e476b727d19dc6f95cb2326193607"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aa10e476b727d19dc6f95cb2326193607">processor_affinity</a> () override</td></tr>
<tr class="memdesc:aa10e476b727d19dc6f95cb2326193607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current processor affinity.  <br /></td></tr>
<tr class="separator:aa10e476b727d19dc6f95cb2326193607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099f578878243499d63846bbee61979a" id="r_a099f578878243499d63846bbee61979a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a099f578878243499d63846bbee61979a">active_thread_priority</a> ()</td></tr>
<tr class="memdesc:a099f578878243499d63846bbee61979a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current thread priority in use.  <br /></td></tr>
<tr class="separator:a099f578878243499d63846bbee61979a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585b831aea5775730931d7fb9e6e8253" id="r_a585b831aea5775730931d7fb9e6e8253"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a585b831aea5775730931d7fb9e6e8253">thread_priority</a> ()</td></tr>
<tr class="memdesc:a585b831aea5775730931d7fb9e6e8253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current thread priority stored.  <br /></td></tr>
<tr class="separator:a585b831aea5775730931d7fb9e6e8253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e0fd5c4db199e6e6f2fc75cdfb5dfa" id="r_a83e0fd5c4db199e6e6f2fc75cdfb5dfa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a83e0fd5c4db199e6e6f2fc75cdfb5dfa">set_thread_priority</a> (int priority)</td></tr>
<tr class="memdesc:a83e0fd5c4db199e6e6f2fc75cdfb5dfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current thread priority.  <br /></td></tr>
<tr class="separator:a83e0fd5c4db199e6e6f2fc75cdfb5dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c836adc464e4b05983facc66b6e401" id="r_af0c836adc464e4b05983facc66b6e401"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#af0c836adc464e4b05983facc66b6e401">update_rate</a> () const</td></tr>
<tr class="separator:af0c836adc464e4b05983facc66b6e401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4070b0462cce39d66b0c7c90ef2153d8" id="r_a4070b0462cce39d66b0c7c90ef2153d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a4070b0462cce39d66b0c7c90ef2153d8">system_handler</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> msg)</td></tr>
<tr class="memdesc:a4070b0462cce39d66b0c7c90ef2153d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">the system message handler  <br /></td></tr>
<tr class="separator:a4070b0462cce39d66b0c7c90ef2153d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4c10f5f25c47e15f715eee574cd0951" id="r_ae4c10f5f25c47e15f715eee574cd0951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ae4c10f5f25c47e15f715eee574cd0951">set_log_level</a> (const std::string &amp;level) override</td></tr>
<tr class="memdesc:ae4c10f5f25c47e15f715eee574cd0951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the logger's output level.  <br /></td></tr>
<tr class="separator:ae4c10f5f25c47e15f715eee574cd0951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4018d4bbe1bc19569f674003c60cc9" id="r_a7d4018d4bbe1bc19569f674003c60cc9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a7d4018d4bbe1bc19569f674003c60cc9">log_level</a> () override</td></tr>
<tr class="memdesc:a7d4018d4bbe1bc19569f674003c60cc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the logger's output level.  <br /></td></tr>
<tr class="separator:a7d4018d4bbe1bc19569f674003c60cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89242cb1ac9d2bf5e75f923745baa576" id="r_a89242cb1ac9d2bf5e75f923745baa576"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a89242cb1ac9d2bf5e75f923745baa576">finished</a> ()</td></tr>
<tr class="memdesc:a89242cb1ac9d2bf5e75f923745baa576"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true when execution has completed due to a message connection  <br /></td></tr>
<tr class="separator:a89242cb1ac9d2bf5e75f923745baa576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbed8f29e876494528b826c00e30cffa" id="r_acbed8f29e876494528b826c00e30cffa"><td class="memItemLeft" align="right" valign="top">block_detail_sptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#acbed8f29e876494528b826c00e30cffa">detail</a> () const</td></tr>
<tr class="separator:acbed8f29e876494528b826c00e30cffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776fbf15f5280bf8da74929b4ea8bb39" id="r_a776fbf15f5280bf8da74929b4ea8bb39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a776fbf15f5280bf8da74929b4ea8bb39">set_detail</a> (block_detail_sptr <a class="el" href="classgr_1_1block.html#acbed8f29e876494528b826c00e30cffa">detail</a>)</td></tr>
<tr class="separator:a776fbf15f5280bf8da74929b4ea8bb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf235647d7ec77995751de89d94a22a6" id="r_adf235647d7ec77995751de89d94a22a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#adf235647d7ec77995751de89d94a22a6">notify_msg_neighbors</a> ()</td></tr>
<tr class="memdesc:adf235647d7ec77995751de89d94a22a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell msg neighbors we are finished.  <br /></td></tr>
<tr class="separator:adf235647d7ec77995751de89d94a22a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19867ade7536783777a5c5e91b69972" id="r_af19867ade7536783777a5c5e91b69972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#af19867ade7536783777a5c5e91b69972">clear_finished</a> ()</td></tr>
<tr class="memdesc:af19867ade7536783777a5c5e91b69972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure we don't think we are finished.  <br /></td></tr>
<tr class="separator:af19867ade7536783777a5c5e91b69972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77149752323d0e1309cf43d66a31ae65" id="r_a77149752323d0e1309cf43d66a31ae65"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a77149752323d0e1309cf43d66a31ae65">identifier</a> () const</td></tr>
<tr class="separator:a77149752323d0e1309cf43d66a31ae65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgr_1_1basic__block"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgr_1_1basic__block')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgr_1_1basic__block.html">gr::basic_block</a></td></tr>
<tr class="memitem:a15300c27e1a332bc7dcff6438ec6c080 inherit pub_methods_classgr_1_1basic__block" id="r_a15300c27e1a332bc7dcff6438ec6c080"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a15300c27e1a332bc7dcff6438ec6c080">message_subscribers</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> port)</td></tr>
<tr class="separator:a15300c27e1a332bc7dcff6438ec6c080 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1b212d7fb9637d34d078b073e7e803 inherit pub_methods_classgr_1_1basic__block" id="r_a6f1b212d7fb9637d34d078b073e7e803"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a6f1b212d7fb9637d34d078b073e7e803">~basic_block</a> () override</td></tr>
<tr class="separator:a6f1b212d7fb9637d34d078b073e7e803 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e458ea6cf1129f1c3bb6f66229303ca inherit pub_methods_classgr_1_1basic__block" id="r_a2e458ea6cf1129f1c3bb6f66229303ca"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a2e458ea6cf1129f1c3bb6f66229303ca">unique_id</a> () const</td></tr>
<tr class="separator:a2e458ea6cf1129f1c3bb6f66229303ca inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c225b210f999a526e5b714eb603ddd5 inherit pub_methods_classgr_1_1basic__block" id="r_a7c225b210f999a526e5b714eb603ddd5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a7c225b210f999a526e5b714eb603ddd5">symbolic_id</a> () const</td></tr>
<tr class="separator:a7c225b210f999a526e5b714eb603ddd5 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a5056e2de6b3e561c02f2de37de44c inherit pub_methods_classgr_1_1basic__block" id="r_af3a5056e2de6b3e561c02f2de37de44c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#af3a5056e2de6b3e561c02f2de37de44c">name</a> () const</td></tr>
<tr class="separator:af3a5056e2de6b3e561c02f2de37de44c inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4985e58945604020bb5fd252df7b4c5 inherit pub_methods_classgr_1_1basic__block" id="r_ab4985e58945604020bb5fd252df7b4c5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ab4985e58945604020bb5fd252df7b4c5">symbol_name</a> () const</td></tr>
<tr class="separator:ab4985e58945604020bb5fd252df7b4c5 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aab2dfa9aab194186d3737facb1cd46 inherit pub_methods_classgr_1_1basic__block" id="r_a7aab2dfa9aab194186d3737facb1cd46"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a7aab2dfa9aab194186d3737facb1cd46">identifier</a> () const</td></tr>
<tr class="separator:a7aab2dfa9aab194186d3737facb1cd46 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0067e4bfc94bd79182de1a9c7ab7d267 inherit pub_methods_classgr_1_1basic__block" id="r_a0067e4bfc94bd79182de1a9c7ab7d267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a0067e4bfc94bd79182de1a9c7ab7d267">input_signature</a> () const</td></tr>
<tr class="separator:a0067e4bfc94bd79182de1a9c7ab7d267 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a185fca1da861c9e6213f9e8284fed inherit pub_methods_classgr_1_1basic__block" id="r_ae1a185fca1da861c9e6213f9e8284fed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ae1a185fca1da861c9e6213f9e8284fed">output_signature</a> () const</td></tr>
<tr class="separator:ae1a185fca1da861c9e6213f9e8284fed inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bf6924dfa0bb724caca46575669557 inherit pub_methods_classgr_1_1basic__block" id="r_a84bf6924dfa0bb724caca46575669557"><td class="memItemLeft" align="right" valign="top">basic_block_sptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a84bf6924dfa0bb724caca46575669557">to_basic_block</a> ()</td></tr>
<tr class="separator:a84bf6924dfa0bb724caca46575669557 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5fd45a3aab213bdf7e826ef0baf654 inherit pub_methods_classgr_1_1basic__block" id="r_abd5fd45a3aab213bdf7e826ef0baf654"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#abd5fd45a3aab213bdf7e826ef0baf654">alias_set</a> () const</td></tr>
<tr class="separator:abd5fd45a3aab213bdf7e826ef0baf654 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bc65ad989bb7aa762e9f6064e05534 inherit pub_methods_classgr_1_1basic__block" id="r_ab6bc65ad989bb7aa762e9f6064e05534"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ab6bc65ad989bb7aa762e9f6064e05534">alias</a> () const</td></tr>
<tr class="separator:ab6bc65ad989bb7aa762e9f6064e05534 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c23228d2623680d85ce836dea19da21 inherit pub_methods_classgr_1_1basic__block" id="r_a7c23228d2623680d85ce836dea19da21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a7c23228d2623680d85ce836dea19da21">alias_pmt</a> () const</td></tr>
<tr class="separator:a7c23228d2623680d85ce836dea19da21 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5251b68da76a9ce6bef105ef8136547 inherit pub_methods_classgr_1_1basic__block" id="r_ad5251b68da76a9ce6bef105ef8136547"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ad5251b68da76a9ce6bef105ef8136547">set_block_alias</a> (std::string <a class="el" href="classgr_1_1basic__block.html#af3a5056e2de6b3e561c02f2de37de44c">name</a>)</td></tr>
<tr class="separator:ad5251b68da76a9ce6bef105ef8136547 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362b6de38292cca9c1d56439a6efad04 inherit pub_methods_classgr_1_1basic__block" id="r_a362b6de38292cca9c1d56439a6efad04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a362b6de38292cca9c1d56439a6efad04">message_port_register_in</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> port_id)</td></tr>
<tr class="separator:a362b6de38292cca9c1d56439a6efad04 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3047921885668943a13dabd35d5eda4 inherit pub_methods_classgr_1_1basic__block" id="r_ac3047921885668943a13dabd35d5eda4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ac3047921885668943a13dabd35d5eda4">message_port_register_out</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> port_id)</td></tr>
<tr class="separator:ac3047921885668943a13dabd35d5eda4 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485fa8f9fa04a1abcfe3f111d22e8e5f inherit pub_methods_classgr_1_1basic__block" id="r_a485fa8f9fa04a1abcfe3f111d22e8e5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a485fa8f9fa04a1abcfe3f111d22e8e5f">message_port_pub</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> port_id, <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> msg)</td></tr>
<tr class="separator:a485fa8f9fa04a1abcfe3f111d22e8e5f inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddd339f229f55bd96229d7a7dd5cc8f inherit pub_methods_classgr_1_1basic__block" id="r_adddd339f229f55bd96229d7a7dd5cc8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#adddd339f229f55bd96229d7a7dd5cc8f">message_port_sub</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> port_id, <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> target)</td></tr>
<tr class="separator:adddd339f229f55bd96229d7a7dd5cc8f inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5496693b3c7c8be32529d695f83db1c inherit pub_methods_classgr_1_1basic__block" id="r_ad5496693b3c7c8be32529d695f83db1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ad5496693b3c7c8be32529d695f83db1c">message_port_unsub</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> port_id, <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> target)</td></tr>
<tr class="separator:ad5496693b3c7c8be32529d695f83db1c inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8780d41bb2091c00a9637e15e872a7ce inherit pub_methods_classgr_1_1basic__block" id="r_a8780d41bb2091c00a9637e15e872a7ce"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a8780d41bb2091c00a9637e15e872a7ce">message_port_is_hier</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> port_id)</td></tr>
<tr class="separator:a8780d41bb2091c00a9637e15e872a7ce inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc9ea399d0940de8440e028b7352ed7 inherit pub_methods_classgr_1_1basic__block" id="r_a5cc9ea399d0940de8440e028b7352ed7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a5cc9ea399d0940de8440e028b7352ed7">message_port_is_hier_in</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> port_id)</td></tr>
<tr class="separator:a5cc9ea399d0940de8440e028b7352ed7 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218a3ea133d838c8344fb3914c54ba3a inherit pub_methods_classgr_1_1basic__block" id="r_a218a3ea133d838c8344fb3914c54ba3a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a218a3ea133d838c8344fb3914c54ba3a">message_port_is_hier_out</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> port_id)</td></tr>
<tr class="separator:a218a3ea133d838c8344fb3914c54ba3a inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92faa0b6775de0100f6d202140403a2 inherit pub_methods_classgr_1_1basic__block" id="r_ae92faa0b6775de0100f6d202140403a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ae92faa0b6775de0100f6d202140403a2">message_ports_in</a> ()</td></tr>
<tr class="memdesc:ae92faa0b6775de0100f6d202140403a2 inherit pub_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get input message port names.  <br /></td></tr>
<tr class="separator:ae92faa0b6775de0100f6d202140403a2 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6351658056b5381f3803233cb75c928 inherit pub_methods_classgr_1_1basic__block" id="r_ad6351658056b5381f3803233cb75c928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ad6351658056b5381f3803233cb75c928">message_ports_out</a> ()</td></tr>
<tr class="memdesc:ad6351658056b5381f3803233cb75c928 inherit pub_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get output message port names.  <br /></td></tr>
<tr class="separator:ad6351658056b5381f3803233cb75c928 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82376fe13f515cb904c0d2e9fec87b6 inherit pub_methods_classgr_1_1basic__block" id="r_ab82376fe13f515cb904c0d2e9fec87b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ab82376fe13f515cb904c0d2e9fec87b6">_post</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port, <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> msg)</td></tr>
<tr class="separator:ab82376fe13f515cb904c0d2e9fec87b6 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4958dfb6cc37d60db6afaba91f6e6e inherit pub_methods_classgr_1_1basic__block" id="r_aea4958dfb6cc37d60db6afaba91f6e6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#aea4958dfb6cc37d60db6afaba91f6e6e">empty_p</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port)</td></tr>
<tr class="memdesc:aea4958dfb6cc37d60db6afaba91f6e6e inherit pub_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">is the queue empty?  <br /></td></tr>
<tr class="separator:aea4958dfb6cc37d60db6afaba91f6e6e inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb5d318b3d3689e6f7f448d29a03032 inherit pub_methods_classgr_1_1basic__block" id="r_aecb5d318b3d3689e6f7f448d29a03032"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#aecb5d318b3d3689e6f7f448d29a03032">empty_p</a> ()</td></tr>
<tr class="separator:aecb5d318b3d3689e6f7f448d29a03032 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea70146bf5ce65a8c20c0b7234063d9 inherit pub_methods_classgr_1_1basic__block" id="r_a0ea70146bf5ce65a8c20c0b7234063d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a0ea70146bf5ce65a8c20c0b7234063d9">empty_handled_p</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port)</td></tr>
<tr class="memdesc:a0ea70146bf5ce65a8c20c0b7234063d9 inherit pub_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">are all msg ports with handlers empty?  <br /></td></tr>
<tr class="separator:a0ea70146bf5ce65a8c20c0b7234063d9 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b7c42c06430e9f5330f7462a5350a1 inherit pub_methods_classgr_1_1basic__block" id="r_a75b7c42c06430e9f5330f7462a5350a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a75b7c42c06430e9f5330f7462a5350a1">empty_handled_p</a> ()</td></tr>
<tr class="separator:a75b7c42c06430e9f5330f7462a5350a1 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3baf2d69f2a00871c89993e28b50ea inherit pub_methods_classgr_1_1basic__block" id="r_a4e3baf2d69f2a00871c89993e28b50ea"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a4e3baf2d69f2a00871c89993e28b50ea">nmsgs</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port)</td></tr>
<tr class="memdesc:a4e3baf2d69f2a00871c89993e28b50ea inherit pub_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many messages in the queue?  <br /></td></tr>
<tr class="separator:a4e3baf2d69f2a00871c89993e28b50ea inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf0d8127f9b1da8dcb327b29391812a inherit pub_methods_classgr_1_1basic__block" id="r_acbf0d8127f9b1da8dcb327b29391812a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#acbf0d8127f9b1da8dcb327b29391812a">insert_tail</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port, <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> msg)</td></tr>
<tr class="separator:acbf0d8127f9b1da8dcb327b29391812a inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e69c810222df1bccbd159d660eda06 inherit pub_methods_classgr_1_1basic__block" id="r_af9e69c810222df1bccbd159d660eda06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#af9e69c810222df1bccbd159d660eda06">delete_head_nowait</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port)</td></tr>
<tr class="separator:af9e69c810222df1bccbd159d660eda06 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33724cc678371b3713e13ed29217963e inherit pub_methods_classgr_1_1basic__block" id="r_a33724cc678371b3713e13ed29217963e"><td class="memItemLeft" align="right" valign="top">msg_queue_t::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a33724cc678371b3713e13ed29217963e">get_iterator</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port)</td></tr>
<tr class="separator:a33724cc678371b3713e13ed29217963e inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffa27c6be8af72ae44773185687d49c inherit pub_methods_classgr_1_1basic__block" id="r_acffa27c6be8af72ae44773185687d49c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#acffa27c6be8af72ae44773185687d49c">erase_msg</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port, msg_queue_t::iterator it)</td></tr>
<tr class="separator:acffa27c6be8af72ae44773185687d49c inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdeb25c366bedbadf918b7f106dbf85 inherit pub_methods_classgr_1_1basic__block" id="r_a8cdeb25c366bedbadf918b7f106dbf85"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a8cdeb25c366bedbadf918b7f106dbf85">has_msg_port</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port)</td></tr>
<tr class="separator:a8cdeb25c366bedbadf918b7f106dbf85 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fdffa888cd7433a1fe06caa6de2ec8 inherit pub_methods_classgr_1_1basic__block" id="r_a30fdffa888cd7433a1fe06caa6de2ec8"><td class="memItemLeft" align="right" valign="top">const msg_queue_map_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a30fdffa888cd7433a1fe06caa6de2ec8">get_msg_map</a> (void) const</td></tr>
<tr class="separator:a30fdffa888cd7433a1fe06caa6de2ec8 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8bf6b9f28014657a6e8b5f25ca7802 inherit pub_methods_classgr_1_1basic__block" id="r_a7f8bf6b9f28014657a6e8b5f25ca7802"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a7f8bf6b9f28014657a6e8b5f25ca7802">setup_rpc</a> ()</td></tr>
<tr class="memdesc:a7f8bf6b9f28014657a6e8b5f25ca7802 inherit pub_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up the RPC registered variables.  <br /></td></tr>
<tr class="separator:a7f8bf6b9f28014657a6e8b5f25ca7802 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bd994a51158fd3803377960d688795 inherit pub_methods_classgr_1_1basic__block" id="r_a10bd994a51158fd3803377960d688795"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a10bd994a51158fd3803377960d688795">is_rpc_set</a> ()</td></tr>
<tr class="memdesc:a10bd994a51158fd3803377960d688795 inherit pub_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask if this block has been registered to the RPC.  <br /></td></tr>
<tr class="separator:a10bd994a51158fd3803377960d688795 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac349eee015757c75f8486b36ee08b106 inherit pub_methods_classgr_1_1basic__block" id="r_ac349eee015757c75f8486b36ee08b106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ac349eee015757c75f8486b36ee08b106">rpc_set</a> ()</td></tr>
<tr class="memdesc:ac349eee015757c75f8486b36ee08b106 inherit pub_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">When the block is registered with the RPC, set this.  <br /></td></tr>
<tr class="separator:ac349eee015757c75f8486b36ee08b106 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca13d6f083397aada5b44d0f349ce151 inherit pub_methods_classgr_1_1basic__block" id="r_aca13d6f083397aada5b44d0f349ce151"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#aca13d6f083397aada5b44d0f349ce151">check_topology</a> (int ninputs, int noutputs)</td></tr>
<tr class="memdesc:aca13d6f083397aada5b44d0f349ce151 inherit pub_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Confirm that ninputs and noutputs is an acceptable combination.  <br /></td></tr>
<tr class="separator:aca13d6f083397aada5b44d0f349ce151 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fed11ec01538bfea999fb37687b43b4 inherit pub_methods_classgr_1_1basic__block" id="r_a7fed11ec01538bfea999fb37687b43b4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fed11ec01538bfea999fb37687b43b4 inherit pub_methods_classgr_1_1basic__block"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a7fed11ec01538bfea999fb37687b43b4">set_msg_handler</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port, T <a class="el" href="classgr_1_1msg__handler.html">msg_handler</a>)</td></tr>
<tr class="memdesc:a7fed11ec01538bfea999fb37687b43b4 inherit pub_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback that is fired when messages are available.  <br /></td></tr>
<tr class="separator:a7fed11ec01538bfea999fb37687b43b4 inherit pub_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgr_1_1msg__accepter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgr_1_1msg__accepter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgr_1_1msg__accepter.html">gr::msg_accepter</a></td></tr>
<tr class="memitem:ae25bb0b46019f4dbe2bdcecdf50dc755 inherit pub_methods_classgr_1_1msg__accepter" id="r_ae25bb0b46019f4dbe2bdcecdf50dc755"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1msg__accepter.html#ae25bb0b46019f4dbe2bdcecdf50dc755">msg_accepter</a> ()</td></tr>
<tr class="separator:ae25bb0b46019f4dbe2bdcecdf50dc755 inherit pub_methods_classgr_1_1msg__accepter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c38c26efbfb1c4fd05eae97d2de748 inherit pub_methods_classgr_1_1msg__accepter" id="r_a06c38c26efbfb1c4fd05eae97d2de748"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1msg__accepter.html#a06c38c26efbfb1c4fd05eae97d2de748">~msg_accepter</a> () override</td></tr>
<tr class="separator:a06c38c26efbfb1c4fd05eae97d2de748 inherit pub_methods_classgr_1_1msg__accepter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1032a8f3bf410b7670bc9af0c7c6d7ad inherit pub_methods_classgr_1_1msg__accepter" id="r_a1032a8f3bf410b7670bc9af0c7c6d7ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1msg__accepter.html#a1032a8f3bf410b7670bc9af0c7c6d7ad">post</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port, <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> msg) override</td></tr>
<tr class="memdesc:a1032a8f3bf410b7670bc9af0c7c6d7ad inherit pub_methods_classgr_1_1msg__accepter"><td class="mdescLeft">&#160;</td><td class="mdescRight">send <code>msg</code> to <code><a class="el" href="classgr_1_1msg__accepter.html" title="Accepts messages and inserts them into a message queue, then notifies subclass gr::basic_block there ...">msg_accepter</a></code> on port <code>which_port</code>  <br /></td></tr>
<tr class="separator:a1032a8f3bf410b7670bc9af0c7c6d7ad inherit pub_methods_classgr_1_1msg__accepter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classgr_1_1messages_1_1msg__accepter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classgr_1_1messages_1_1msg__accepter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classgr_1_1messages_1_1msg__accepter.html">gr::messages::msg_accepter</a></td></tr>
<tr class="memitem:ad6092d4c7f34d71ceb85d1f0d261184f inherit pub_methods_classgr_1_1messages_1_1msg__accepter" id="r_ad6092d4c7f34d71ceb85d1f0d261184f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1messages_1_1msg__accepter.html#ad6092d4c7f34d71ceb85d1f0d261184f">msg_accepter</a> ()</td></tr>
<tr class="separator:ad6092d4c7f34d71ceb85d1f0d261184f inherit pub_methods_classgr_1_1messages_1_1msg__accepter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a624c3e070c3df38e5d11e4acd0f59b46" id="r_a624c3e070c3df38e5d11e4acd0f59b46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a624c3e070c3df38e5d11e4acd0f59b46">block</a> (void)</td></tr>
<tr class="separator:a624c3e070c3df38e5d11e4acd0f59b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbc2ed68daafc4de5ee0f5df21efe6e" id="r_aebbc2ed68daafc4de5ee0f5df21efe6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aebbc2ed68daafc4de5ee0f5df21efe6e">block</a> (const std::string &amp;<a class="el" href="classgr_1_1basic__block.html#af3a5056e2de6b3e561c02f2de37de44c">name</a>, <a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a> <a class="el" href="classgr_1_1basic__block.html#a0067e4bfc94bd79182de1a9c7ab7d267">input_signature</a>, <a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a> <a class="el" href="classgr_1_1basic__block.html#ae1a185fca1da861c9e6213f9e8284fed">output_signature</a>)</td></tr>
<tr class="separator:aebbc2ed68daafc4de5ee0f5df21efe6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa927cd4d5b8993122cf60dd556ffe62d" id="r_aa927cd4d5b8993122cf60dd556ffe62d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aa927cd4d5b8993122cf60dd556ffe62d">set_fixed_rate</a> (bool <a class="el" href="classgr_1_1block.html#ab82ebb52662cf4fa6b1417d3571414da">fixed_rate</a>)</td></tr>
<tr class="separator:aa927cd4d5b8993122cf60dd556ffe62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7cc51b9d289124d6843bb392f564fc" id="r_a8b7cc51b9d289124d6843bb392f564fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a8b7cc51b9d289124d6843bb392f564fc">add_item_tag</a> (unsigned int which_output, uint64_t abs_offset, const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;key, const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;value, const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;srcid=pmt::PMT_F)</td></tr>
<tr class="memdesc:a8b7cc51b9d289124d6843bb392f564fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new tag onto the given output buffer.  <br /></td></tr>
<tr class="separator:a8b7cc51b9d289124d6843bb392f564fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0ee37749a77d3f40a5bb04233f6028" id="r_a8f0ee37749a77d3f40a5bb04233f6028"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a8f0ee37749a77d3f40a5bb04233f6028">add_item_tag</a> (unsigned int which_output, const <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &amp;tag)</td></tr>
<tr class="memdesc:a8f0ee37749a77d3f40a5bb04233f6028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new tag onto the given output buffer.  <br /></td></tr>
<tr class="separator:a8f0ee37749a77d3f40a5bb04233f6028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461f6cc92174e83b10c3ec5336036768" id="r_a461f6cc92174e83b10c3ec5336036768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a461f6cc92174e83b10c3ec5336036768">remove_item_tag</a> (unsigned int which_input, uint64_t abs_offset, const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;key, const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;value, const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;srcid=pmt::PMT_F)</td></tr>
<tr class="memdesc:a461f6cc92174e83b10c3ec5336036768"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED. Will be removed in 3.8.  <br /></td></tr>
<tr class="separator:a461f6cc92174e83b10c3ec5336036768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94906298cd5995a94172c53dbfbc77dd" id="r_a94906298cd5995a94172c53dbfbc77dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a94906298cd5995a94172c53dbfbc77dd">remove_item_tag</a> (unsigned int which_input, const <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &amp;tag)</td></tr>
<tr class="memdesc:a94906298cd5995a94172c53dbfbc77dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED. Will be removed in 3.8.  <br /></td></tr>
<tr class="separator:a94906298cd5995a94172c53dbfbc77dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0272555827fe26a1878e53ce4be092c" id="r_aa0272555827fe26a1878e53ce4be092c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aa0272555827fe26a1878e53ce4be092c">get_tags_in_range</a> (std::vector&lt; <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &gt; &amp;<a class="el" href="structv.html">v</a>, unsigned int which_input, uint64_t abs_start, uint64_t abs_end)</td></tr>
<tr class="memdesc:aa0272555827fe26a1878e53ce4be092c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a [start,end), returns a vector of all tags in the range.  <br /></td></tr>
<tr class="separator:aa0272555827fe26a1878e53ce4be092c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83143d92b16b5bf93bf43a66a46bb60e" id="r_a83143d92b16b5bf93bf43a66a46bb60e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a83143d92b16b5bf93bf43a66a46bb60e">get_tags_in_range</a> (std::vector&lt; <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &gt; &amp;<a class="el" href="structv.html">v</a>, unsigned int which_input, uint64_t abs_start, uint64_t abs_end, const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;key)</td></tr>
<tr class="memdesc:a83143d92b16b5bf93bf43a66a46bb60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a [start,end), returns a vector of all tags in the range with a given key.  <br /></td></tr>
<tr class="separator:a83143d92b16b5bf93bf43a66a46bb60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf2cc497d68c4650be55765d0fe12291" id="r_abf2cc497d68c4650be55765d0fe12291"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#abf2cc497d68c4650be55765d0fe12291">get_tags_in_window</a> (std::vector&lt; <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &gt; &amp;<a class="el" href="structv.html">v</a>, unsigned int which_input, uint64_t rel_start, uint64_t rel_end)</td></tr>
<tr class="memdesc:abf2cc497d68c4650be55765d0fe12291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets all tags within the relative window of the current call to work.  <br /></td></tr>
<tr class="separator:abf2cc497d68c4650be55765d0fe12291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451b95d244e27e815eb3f9e56ea6ac32" id="r_a451b95d244e27e815eb3f9e56ea6ac32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a451b95d244e27e815eb3f9e56ea6ac32">get_tags_in_window</a> (std::vector&lt; <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &gt; &amp;<a class="el" href="structv.html">v</a>, unsigned int which_input, uint64_t rel_start, uint64_t rel_end, const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;key)</td></tr>
<tr class="memdesc:a451b95d244e27e815eb3f9e56ea6ac32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operates like <a class="el" href="classgr_1_1block.html#abf2cc497d68c4650be55765d0fe12291" title="Gets all tags within the relative window of the current call to work.">gr::block::get_tags_in_window</a> with the ability to only return tags with the specified <code>key</code>.  <br /></td></tr>
<tr class="separator:a451b95d244e27e815eb3f9e56ea6ac32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d3cc9f05edecef8b7bda7f16580848" id="r_a71d3cc9f05edecef8b7bda7f16580848"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a71d3cc9f05edecef8b7bda7f16580848">enable_update_rate</a> (bool en)</td></tr>
<tr class="separator:a71d3cc9f05edecef8b7bda7f16580848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725dd951d233c6f3f2a5eccce0117033" id="r_a725dd951d233c6f3f2a5eccce0117033"><td class="memItemLeft" align="right" valign="top">buffer_sptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a725dd951d233c6f3f2a5eccce0117033">allocate_buffer</a> (size_t port, int downstream_max_nitems, uint64_t downstream_lcm_nitems, uint32_t downstream_max_out_mult)</td></tr>
<tr class="memdesc:a725dd951d233c6f3f2a5eccce0117033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a buffer for the given output port of this block. Note that the downstream max number of items must be passed in to this function for consideration.  <br /></td></tr>
<tr class="separator:a725dd951d233c6f3f2a5eccce0117033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classgr_1_1basic__block"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classgr_1_1basic__block')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classgr_1_1basic__block.html">gr::basic_block</a></td></tr>
<tr class="memitem:a6cc897729213ab4d2e3ade44c6942100 inherit pro_methods_classgr_1_1basic__block" id="r_a6cc897729213ab4d2e3ade44c6942100"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a6cc897729213ab4d2e3ade44c6942100">basic_block</a> (void)</td></tr>
<tr class="separator:a6cc897729213ab4d2e3ade44c6942100 inherit pro_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451b45483aec67682289f4cf94e53f74 inherit pro_methods_classgr_1_1basic__block" id="r_a451b45483aec67682289f4cf94e53f74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a451b45483aec67682289f4cf94e53f74">basic_block</a> (const std::string &amp;<a class="el" href="classgr_1_1basic__block.html#af3a5056e2de6b3e561c02f2de37de44c">name</a>, <a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a> <a class="el" href="classgr_1_1basic__block.html#a0067e4bfc94bd79182de1a9c7ab7d267">input_signature</a>, <a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a> <a class="el" href="classgr_1_1basic__block.html#ae1a185fca1da861c9e6213f9e8284fed">output_signature</a>)</td></tr>
<tr class="memdesc:a451b45483aec67682289f4cf94e53f74 inherit pro_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protected constructor prevents instantiation by non-derived classes.  <br /></td></tr>
<tr class="separator:a451b45483aec67682289f4cf94e53f74 inherit pro_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3f8f70bd0f0f2925b09bb75725c2b6 inherit pro_methods_classgr_1_1basic__block" id="r_a3f3f8f70bd0f0f2925b09bb75725c2b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a3f3f8f70bd0f0f2925b09bb75725c2b6">set_input_signature</a> (<a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a> iosig)</td></tr>
<tr class="memdesc:a3f3f8f70bd0f0f2925b09bb75725c2b6 inherit pro_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">may only be called during constructor  <br /></td></tr>
<tr class="separator:a3f3f8f70bd0f0f2925b09bb75725c2b6 inherit pro_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7933b6bc4ad512774bbb40616cc31b4d inherit pro_methods_classgr_1_1basic__block" id="r_a7933b6bc4ad512774bbb40616cc31b4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a7933b6bc4ad512774bbb40616cc31b4d">set_output_signature</a> (<a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a> iosig)</td></tr>
<tr class="memdesc:a7933b6bc4ad512774bbb40616cc31b4d inherit pro_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">may only be called during constructor  <br /></td></tr>
<tr class="separator:a7933b6bc4ad512774bbb40616cc31b4d inherit pro_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4a58849217d8b76ba2d25c0dfd8bd0 inherit pro_methods_classgr_1_1basic__block" id="r_a2c4a58849217d8b76ba2d25c0dfd8bd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a2c4a58849217d8b76ba2d25c0dfd8bd0">set_color</a> (<a class="el" href="classgr_1_1basic__block.html#ac84f6979cb9e7650de9d9205901401aa">vcolor</a> <a class="el" href="classgr_1_1basic__block.html#ae6531de80c07321b7fb6f93d47952a12">color</a>)</td></tr>
<tr class="memdesc:a2c4a58849217d8b76ba2d25c0dfd8bd0 inherit pro_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow the flowgraph to set for sorting and partitioning.  <br /></td></tr>
<tr class="separator:a2c4a58849217d8b76ba2d25c0dfd8bd0 inherit pro_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6531de80c07321b7fb6f93d47952a12 inherit pro_methods_classgr_1_1basic__block" id="r_ae6531de80c07321b7fb6f93d47952a12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgr_1_1basic__block.html#ac84f6979cb9e7650de9d9205901401aa">vcolor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ae6531de80c07321b7fb6f93d47952a12">color</a> () const</td></tr>
<tr class="separator:ae6531de80c07321b7fb6f93d47952a12 inherit pro_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bf058b47b635100945e20f3cc5d0b0 inherit pro_methods_classgr_1_1basic__block" id="r_ac8bf058b47b635100945e20f3cc5d0b0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ac8bf058b47b635100945e20f3cc5d0b0">has_msg_handler</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port)</td></tr>
<tr class="memdesc:ac8bf058b47b635100945e20f3cc5d0b0 inherit pro_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if there is a handler attached to port <code>which_port</code>.  <br /></td></tr>
<tr class="separator:ac8bf058b47b635100945e20f3cc5d0b0 inherit pro_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c8bc1d82de984c872fbaefc0ff954b inherit pro_methods_classgr_1_1basic__block" id="r_aa0c8bc1d82de984c872fbaefc0ff954b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#aa0c8bc1d82de984c872fbaefc0ff954b">dispatch_msg</a> (<a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> which_port, <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> msg)</td></tr>
<tr class="separator:aa0c8bc1d82de984c872fbaefc0ff954b inherit pro_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3a3265861764bbfb189e70f7a68cf1 inherit pro_methods_classgr_1_1basic__block" id="r_a5b3a3265861764bbfb189e70f7a68cf1"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a5b3a3265861764bbfb189e70f7a68cf1 inherit pro_methods_classgr_1_1basic__block"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a5b3a3265861764bbfb189e70f7a68cf1">shared_from_base</a> ()</td></tr>
<tr class="memdesc:a5b3a3265861764bbfb189e70f7a68cf1 inherit pro_methods_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is meant to be called by derived classes (e.g. block) to get a shared pointer internally. This is needed because std::enable_shared_from_this doesn't seem to work with derived classes in an inheritance hierarchy.  <br /></td></tr>
<tr class="separator:a5b3a3265861764bbfb189e70f7a68cf1 inherit pro_methods_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab740ebd7e5e88ab5ed7039db9f054db1" id="r_ab740ebd7e5e88ab5ed7039db9f054db1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ab740ebd7e5e88ab5ed7039db9f054db1">d_max_output_buffer</a></td></tr>
<tr class="separator:ab740ebd7e5e88ab5ed7039db9f054db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c393a6daebc82ddf6844a62f1c5e8ae" id="r_a4c393a6daebc82ddf6844a62f1c5e8ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a4c393a6daebc82ddf6844a62f1c5e8ae">d_min_output_buffer</a></td></tr>
<tr class="separator:a4c393a6daebc82ddf6844a62f1c5e8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b2991658d2d61fa34f776f557f5d508" id="r_a8b2991658d2d61fa34f776f557f5d508"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a8b2991658d2d61fa34f776f557f5d508">d_blkd_input_timer_value</a> = 250</td></tr>
<tr class="separator:a8b2991658d2d61fa34f776f557f5d508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5b8dd7bba021af7bd93f39453f7482" id="r_aaf5b8dd7bba021af7bd93f39453f7482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegr_1_1thread.html#a36ddd13da52283c5a38d285cd901d348">gr::thread::mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#aaf5b8dd7bba021af7bd93f39453f7482">d_setlock</a></td></tr>
<tr class="separator:aaf5b8dd7bba021af7bd93f39453f7482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72091916b86278b58b6d106876b3e8c" id="r_ad72091916b86278b58b6d106876b3e8c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#ad72091916b86278b58b6d106876b3e8c">d_pmt_done</a></td></tr>
<tr class="separator:ad72091916b86278b58b6d106876b3e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2460fc9ff6df7f38a51dadba06b94904" id="r_a2460fc9ff6df7f38a51dadba06b94904"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1block.html#a2460fc9ff6df7f38a51dadba06b94904">d_system_port</a></td></tr>
<tr class="separator:a2460fc9ff6df7f38a51dadba06b94904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classgr_1_1basic__block"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classgr_1_1basic__block')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classgr_1_1basic__block.html">gr::basic_block</a></td></tr>
<tr class="memitem:ad7da20e98a288f84597882e047df63f4 inherit pro_attribs_classgr_1_1basic__block" id="r_ad7da20e98a288f84597882e047df63f4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ad7da20e98a288f84597882e047df63f4">d_name</a></td></tr>
<tr class="separator:ad7da20e98a288f84597882e047df63f4 inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d6b200bb5e268424e9e4630cb22e5a inherit pro_attribs_classgr_1_1basic__block" id="r_a84d6b200bb5e268424e9e4630cb22e5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a84d6b200bb5e268424e9e4630cb22e5a">d_input_signature</a></td></tr>
<tr class="separator:a84d6b200bb5e268424e9e4630cb22e5a inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c091a90172b2eb6d617f6346bbce3f inherit pro_attribs_classgr_1_1basic__block" id="r_a84c091a90172b2eb6d617f6346bbce3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a84c091a90172b2eb6d617f6346bbce3f">d_output_signature</a></td></tr>
<tr class="separator:a84c091a90172b2eb6d617f6346bbce3f inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afb0c354fb5fc2141fc7580361c2f00 inherit pro_attribs_classgr_1_1basic__block" id="r_a8afb0c354fb5fc2141fc7580361c2f00"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a8afb0c354fb5fc2141fc7580361c2f00">d_unique_id</a></td></tr>
<tr class="separator:a8afb0c354fb5fc2141fc7580361c2f00 inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7073674b5876118ae50cd7cc5646ad80 inherit pro_attribs_classgr_1_1basic__block" id="r_a7073674b5876118ae50cd7cc5646ad80"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a7073674b5876118ae50cd7cc5646ad80">d_symbolic_id</a></td></tr>
<tr class="separator:a7073674b5876118ae50cd7cc5646ad80 inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b5f158f329834b12d9b204cf62a10e inherit pro_attribs_classgr_1_1basic__block" id="r_af6b5f158f329834b12d9b204cf62a10e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#af6b5f158f329834b12d9b204cf62a10e">d_symbol_name</a></td></tr>
<tr class="separator:af6b5f158f329834b12d9b204cf62a10e inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de4ae58aaf6af63fe57ecf0e64dcbe0 inherit pro_attribs_classgr_1_1basic__block" id="r_a2de4ae58aaf6af63fe57ecf0e64dcbe0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a2de4ae58aaf6af63fe57ecf0e64dcbe0">d_symbol_alias</a></td></tr>
<tr class="separator:a2de4ae58aaf6af63fe57ecf0e64dcbe0 inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7a00e9e0ff69ceb903d3d6ff506473 inherit pro_attribs_classgr_1_1basic__block" id="r_afc7a00e9e0ff69ceb903d3d6ff506473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classgr_1_1basic__block.html#ac84f6979cb9e7650de9d9205901401aa">vcolor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#afc7a00e9e0ff69ceb903d3d6ff506473">d_color</a></td></tr>
<tr class="separator:afc7a00e9e0ff69ceb903d3d6ff506473 inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d54f7ea6ebf134e68e028294488354d inherit pro_attribs_classgr_1_1basic__block" id="r_a8d54f7ea6ebf134e68e028294488354d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a8d54f7ea6ebf134e68e028294488354d">d_rpc_set</a></td></tr>
<tr class="separator:a8d54f7ea6ebf134e68e028294488354d inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65abdb3eefde2c95646944b18094dddc inherit pro_attribs_classgr_1_1basic__block" id="r_a65abdb3eefde2c95646944b18094dddc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegr.html#a151431341c1556ca0703e304eac650c8">gr::logger_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a65abdb3eefde2c95646944b18094dddc">d_logger</a></td></tr>
<tr class="separator:a65abdb3eefde2c95646944b18094dddc inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bd702ed57a052484e8c431b4ba3a63 inherit pro_attribs_classgr_1_1basic__block" id="r_a13bd702ed57a052484e8c431b4ba3a63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacegr.html#a151431341c1556ca0703e304eac650c8">gr::logger_ptr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a13bd702ed57a052484e8c431b4ba3a63">d_debug_logger</a></td></tr>
<tr class="memdesc:a13bd702ed57a052484e8c431b4ba3a63 inherit pro_attribs_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default logger.  <br /></td></tr>
<tr class="separator:a13bd702ed57a052484e8c431b4ba3a63 inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e92e54cda7a02697074705b9a7c08d inherit pro_attribs_classgr_1_1basic__block" id="r_a68e92e54cda7a02697074705b9a7c08d"><td class="memItemLeft" align="right" valign="top">msg_queue_map_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#a68e92e54cda7a02697074705b9a7c08d">msg_queue</a></td></tr>
<tr class="memdesc:a68e92e54cda7a02697074705b9a7c08d inherit pro_attribs_classgr_1_1basic__block"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verbose logger.  <br /></td></tr>
<tr class="separator:a68e92e54cda7a02697074705b9a7c08d inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d5ad853077c6eaf83c0ebce53d14f2 inherit pro_attribs_classgr_1_1basic__block" id="r_ae5d5ad853077c6eaf83c0ebce53d14f2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; rpcbasic_sptr &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ae5d5ad853077c6eaf83c0ebce53d14f2">d_rpc_vars</a></td></tr>
<tr class="separator:ae5d5ad853077c6eaf83c0ebce53d14f2 inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa8ebb27b9d86bef179e30e37f0dfc3 inherit pro_attribs_classgr_1_1basic__block" id="r_aefa8ebb27b9d86bef179e30e37f0dfc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#aefa8ebb27b9d86bef179e30e37f0dfc3">d_message_subscribers</a></td></tr>
<tr class="separator:aefa8ebb27b9d86bef179e30e37f0dfc3 inherit pro_attribs_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_classgr_1_1basic__block"><td colspan="2" onclick="javascript:toggleInherit('pro_types_classgr_1_1basic__block')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="classgr_1_1basic__block.html">gr::basic_block</a></td></tr>
<tr class="memitem:ac84f6979cb9e7650de9d9205901401aa inherit pro_types_classgr_1_1basic__block" id="r_ac84f6979cb9e7650de9d9205901401aa"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgr_1_1basic__block.html#ac84f6979cb9e7650de9d9205901401aa">vcolor</a> { <a class="el" href="classgr_1_1basic__block.html#ac84f6979cb9e7650de9d9205901401aaa42ae6a0efeb1be877a188c7ad4778f50">WHITE</a>
, <a class="el" href="classgr_1_1basic__block.html#ac84f6979cb9e7650de9d9205901401aaa229412131f1cac62bf1cb3c63b12a19d">GREY</a>
, <a class="el" href="classgr_1_1basic__block.html#ac84f6979cb9e7650de9d9205901401aaab729ab9b0c860fece10ea1eddab6ce52">BLACK</a>
 }</td></tr>
<tr class="separator:ac84f6979cb9e7650de9d9205901401aa inherit pro_types_classgr_1_1basic__block"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The abstract base class for all 'terminal' processing blocks. </p>
<p>A signal processing flow is constructed by creating a tree of hierarchical blocks, which at any level may also contain terminal nodes that actually implement signal processing functions. This is the base class for all such leaf nodes.</p>
<p>Blocks have a set of input streams and output streams. The input_signature and output_signature define the number of input streams and output streams respectively, and the type of the data items in each stream.</p>
<p>Blocks report the number of items consumed on each input in <a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5" title="compute output items from input items">general_work()</a>, using <a class="el" href="classgr_1_1block.html#a47193333ce3fe1536fb1663bf314f63d" title="Tell the scheduler how_many_items of input stream which_input were consumed.">consume()</a> or <a class="el" href="classgr_1_1block.html#a12ea5eba701e22a3d023d0ba7c6ee07c" title="Tell the scheduler how_many_items were consumed on each input stream.">consume_each()</a>.</p>
<p>If the same number of items is produced on each output, the block returns that number from <a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5" title="compute output items from input items">general_work()</a>. Otherwise, the block calls <a class="el" href="classgr_1_1block.html#aa5581727d057bdd8113f8b2a3fc5bd66" title="Tell the scheduler how_many_items were produced on output stream which_output.">produce()</a> for each output, then returns WORK_CALLED_PRODUCE. The input and output rates are not required to be related.</p>
<p>User derived blocks override two methods, forecast and general_work, to implement their signal processing behavior. forecast is called by the system scheduler to determine how many items are required on each input stream in order to produce a given number of output items.</p>
<p>general_work is called to perform the signal processing in the block. It reads the input items and writes the output items. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="abc40fd4d514724a5446a2b34b2352b4e" name="abc40fd4d514724a5446a2b34b2352b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc40fd4d514724a5446a2b34b2352b4e">&#9670;&#160;</a></span>tag_propagation_policy_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4e">gr::block::tag_propagation_policy_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enum to represent different tag propagation policies. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abc40fd4d514724a5446a2b34b2352b4ea2e3b11eb10000e0efab110c31a83e502" name="abc40fd4d514724a5446a2b34b2352b4ea2e3b11eb10000e0efab110c31a83e502"></a>TPP_DONT&#160;</td><td class="fielddoc"><p>Scheduler doesn't propagate tags from in- to output. The block itself is free to insert tags as it wants. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc40fd4d514724a5446a2b34b2352b4ea5b3fd823d5f918e588008c0bc876e574" name="abc40fd4d514724a5446a2b34b2352b4ea5b3fd823d5f918e588008c0bc876e574"></a>TPP_ALL_TO_ALL&#160;</td><td class="fielddoc"><p>Propagate tags from all in- to all outputs. The scheduler takes care of that. </p>
</td></tr>
<tr><td class="fieldname"><a id="abc40fd4d514724a5446a2b34b2352b4ea747127b6fb520f34be8ae3f951fdc53c" name="abc40fd4d514724a5446a2b34b2352b4ea747127b6fb520f34be8ae3f951fdc53c"></a>TPP_ONE_TO_ONE&#160;</td><td class="fielddoc"><p>Propagate tags from n. input to n. output. Requires same number of in- and outputs </p>
</td></tr>
<tr><td class="fieldname"><a id="abc40fd4d514724a5446a2b34b2352b4eaadf6e1b257eee0590cc2b26161d08cdc" name="abc40fd4d514724a5446a2b34b2352b4eaadf6e1b257eee0590cc2b26161d08cdc"></a>TPP_CUSTOM&#160;</td><td class="fielddoc"><p>Like TPP_DONT, but signals the block it should implement application-specific forwarding behaviour. </p>
</td></tr>
</table>

</div>
</div>
<a id="aad622109b3f7676df26c6e75dede24ca" name="aad622109b3f7676df26c6e75dede24ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad622109b3f7676df26c6e75dede24ca">&#9670;&#160;</a></span>work_return_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classgr_1_1block.html#aad622109b3f7676df26c6e75dede24ca">gr::block::work_return_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Magic return values from general_work. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aad622109b3f7676df26c6e75dede24caa8cac307593cf1087803f28eee28ff45a" name="aad622109b3f7676df26c6e75dede24caa8cac307593cf1087803f28eee28ff45a"></a>WORK_CALLED_PRODUCE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aad622109b3f7676df26c6e75dede24caa3e2d37c41af566875030fa1376c4203f" name="aad622109b3f7676df26c6e75dede24caa3e2d37c41af566875030fa1376c4203f"></a>WORK_DONE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7713e4b282e743e8aac3df3c1b68fd6d" name="a7713e4b282e743e8aac3df3c1b68fd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7713e4b282e743e8aac3df3c1b68fd6d">&#9670;&#160;</a></span>~block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gr::block::~block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a624c3e070c3df38e5d11e4acd0f59b46" name="a624c3e070c3df38e5d11e4acd0f59b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a624c3e070c3df38e5d11e4acd0f59b46">&#9670;&#160;</a></span>block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gr::block::block </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebbc2ed68daafc4de5ee0f5df21efe6e" name="aebbc2ed68daafc4de5ee0f5df21efe6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebbc2ed68daafc4de5ee0f5df21efe6e">&#9670;&#160;</a></span>block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gr::block::block </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a>&#160;</td>
          <td class="paramname"><em>input_signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgr_1_1io__signature.html#a3aa5219846c4dfe7e8ebf03b322741f1">gr::io_signature::sptr</a>&#160;</td>
          <td class="paramname"><em>output_signature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a099f578878243499d63846bbee61979a" name="a099f578878243499d63846bbee61979a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099f578878243499d63846bbee61979a">&#9670;&#160;</a></span>active_thread_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gr::block::active_thread_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current thread priority in use. </p>

</div>
</div>
<a id="a8f0ee37749a77d3f40a5bb04233f6028" name="a8f0ee37749a77d3f40a5bb04233f6028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0ee37749a77d3f40a5bb04233f6028">&#9670;&#160;</a></span>add_item_tag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::add_item_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>which_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new tag onto the given output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which_output</td><td>an integer of which output stream to attach the tag </td></tr>
    <tr><td class="paramname">tag</td><td>the tag object to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b7cc51b9d289124d6843bb392f564fc" name="a8b7cc51b9d289124d6843bb392f564fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7cc51b9d289124d6843bb392f564fc">&#9670;&#160;</a></span>add_item_tag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::add_item_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>which_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>abs_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;&#160;</td>
          <td class="paramname"><em>srcid</em> = <code>pmt::PMT_F</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a new tag onto the given output buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which_output</td><td>an integer of which output stream to attach the tag </td></tr>
    <tr><td class="paramname">abs_offset</td><td>a uint64 number of the absolute item number associated with the tag. Can get from nitems_written. </td></tr>
    <tr><td class="paramname">key</td><td>the tag key as a PMT symbol </td></tr>
    <tr><td class="paramname">value</td><td>any PMT holding any value for the given key </td></tr>
    <tr><td class="paramname">srcid</td><td>optional source ID specifier; defaults to PMT_F </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structgr_1_1tag__t.html#acbaaaa7b8d36f6feb8ed49dbc1228348">gr::tag_t::key</a>, <a class="el" href="structgr_1_1tag__t.html#a802cccdb470b6fb67c595f4d56ca0e7d">gr::tag_t::offset</a>, <a class="el" href="structgr_1_1tag__t.html#a89daa353004003182c8bd53869e8c653">gr::tag_t::srcid</a>, and <a class="el" href="structgr_1_1tag__t.html#aa17015fdfdc257f56cd8caa143b3fba8">gr::tag_t::value</a>.</p>

</div>
</div>
<a id="a97e9110914ad00e6d8b9b9e4837508c4" name="a97e9110914ad00e6d8b9b9e4837508c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e9110914ad00e6d8b9b9e4837508c4">&#9670;&#160;</a></span>alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gr::block::alignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a725dd951d233c6f3f2a5eccce0117033" name="a725dd951d233c6f3f2a5eccce0117033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725dd951d233c6f3f2a5eccce0117033">&#9670;&#160;</a></span>allocate_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">buffer_sptr gr::block::allocate_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>downstream_max_nitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>downstream_lcm_nitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>downstream_max_out_mult</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a buffer for the given output port of this block. Note that the downstream max number of items must be passed in to this function for consideration. </p>

</div>
</div>
<a id="a43d5b375cade3fc372f620ca7cfb939b" name="a43d5b375cade3fc372f620ca7cfb939b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d5b375cade3fc372f620ca7cfb939b">&#9670;&#160;</a></span>allocate_detail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::allocate_detail </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ninputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noutputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>downstream_max_nitems_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>downstream_lcm_nitems_vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>downstream_max_out_mult_vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate the <a class="el" href="classgr_1_1block__detail.html" title="Implementation details to support the signal processing abstraction.">block_detail</a> and necessary output buffers for this block. </p>

</div>
</div>
<a id="a37b0ee4b7eb7b8d334be0125e8464a71" name="a37b0ee4b7eb7b8d334be0125e8464a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b0ee4b7eb7b8d334be0125e8464a71">&#9670;&#160;</a></span>blkd_input_timer_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gr::block::blkd_input_timer_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Returns timer value set when input is blocked. </p>

</div>
</div>
<a id="af19867ade7536783777a5c5e91b69972" name="af19867ade7536783777a5c5e91b69972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19867ade7536783777a5c5e91b69972">&#9670;&#160;</a></span>clear_finished()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::clear_finished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure we don't think we are finished. </p>

</div>
</div>
<a id="a47193333ce3fe1536fb1663bf314f63d" name="a47193333ce3fe1536fb1663bf314f63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47193333ce3fe1536fb1663bf314f63d">&#9670;&#160;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::consume </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>how_many_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the scheduler <code>how_many_items</code> of input stream <code>which_input</code> were consumed. </p>
<p>This function should be used in <a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5" title="compute output items from input items">general_work()</a> to tell the scheduler the number of input items processed. Calling <a class="el" href="classgr_1_1block.html#a47193333ce3fe1536fb1663bf314f63d" title="Tell the scheduler how_many_items of input stream which_input were consumed.">consume()</a> multiple times in the same <a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5" title="compute output items from input items">general_work()</a> call is safe. Every invocation of <a class="el" href="classgr_1_1block.html#a47193333ce3fe1536fb1663bf314f63d" title="Tell the scheduler how_many_items of input stream which_input were consumed.">consume()</a> updates the values returned by <a class="el" href="classgr_1_1block.html#a2279d1eb421203bc5b0f100a6d5dc263" title="Return the number of items read on input stream which_input.">nitems_read()</a>. </p>

</div>
</div>
<a id="a12ea5eba701e22a3d023d0ba7c6ee07c" name="a12ea5eba701e22a3d023d0ba7c6ee07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ea5eba701e22a3d023d0ba7c6ee07c">&#9670;&#160;</a></span>consume_each()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::consume_each </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>how_many_items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the scheduler <code>how_many_items</code> were consumed on each input stream. </p>
<p>Also see notes on <a class="el" href="classgr_1_1block.html#a47193333ce3fe1536fb1663bf314f63d" title="Tell the scheduler how_many_items of input stream which_input were consumed.">consume()</a>. </p>

</div>
</div>
<a id="acad5d6e62ea885cb77d19f72451581c2" name="acad5d6e62ea885cb77d19f72451581c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad5d6e62ea885cb77d19f72451581c2">&#9670;&#160;</a></span>declare_sample_delay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::declare_sample_delay </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declares the block's delay in samples. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.</p>
<p>This does not actively set the delay; it just tells the scheduler what the delay is.</p>
<p>This delay is mostly used to adjust the placement of the tags and is not currently used for any signal processing. When a tag is passed through a block with internal delay, its location should be moved based on the delay of the block. This interface allows us to tell the scheduler this value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>The buffer on which to set the delay. </td></tr>
    <tr><td class="paramname">delay</td><td>The sample delay of the data stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7df9d4ebb09530cd3be2ad78da411b4" name="aa7df9d4ebb09530cd3be2ad78da411b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7df9d4ebb09530cd3be2ad78da411b4">&#9670;&#160;</a></span>declare_sample_delay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::declare_sample_delay </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>delay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience wrapper to gr::block::declare_delay(int which, unsigned delay) to set all ports to the same delay. </p>

</div>
</div>
<a id="acbed8f29e876494528b826c00e30cffa" name="acbed8f29e876494528b826c00e30cffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbed8f29e876494528b826c00e30cffa">&#9670;&#160;</a></span>detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">block_detail_sptr gr::block::detail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71d3cc9f05edecef8b7bda7f16580848" name="a71d3cc9f05edecef8b7bda7f16580848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d3cc9f05edecef8b7bda7f16580848">&#9670;&#160;</a></span>enable_update_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::enable_update_rate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>en</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bbf96f6a81d5c289934a68ef44dd1b4" name="a9bbf96f6a81d5c289934a68ef44dd1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbf96f6a81d5c289934a68ef44dd1b4">&#9670;&#160;</a></span>expand_minmax_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::expand_minmax_buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89242cb1ac9d2bf5e75f923745baa576" name="a89242cb1ac9d2bf5e75f923745baa576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89242cb1ac9d2bf5e75f923745baa576">&#9670;&#160;</a></span>finished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gr::block::finished </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true when execution has completed due to a message connection </p>

</div>
</div>
<a id="ab82ebb52662cf4fa6b1417d3571414da" name="ab82ebb52662cf4fa6b1417d3571414da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82ebb52662cf4fa6b1417d3571414da">&#9670;&#160;</a></span>fixed_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gr::block::fixed_rate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this block has a fixed input to output rate. </p>
<p>If true, then fixed_rate_in_to_out and fixed_rate_out_to_in may be called. </p>

</div>
</div>
<a id="a95e37b19dd73c24113ca9b848db00d16" name="a95e37b19dd73c24113ca9b848db00d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e37b19dd73c24113ca9b848db00d16">&#9670;&#160;</a></span>fixed_rate_ninput_to_noutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int gr::block::fixed_rate_ninput_to_noutput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ninput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given ninput samples, return number of output samples that will be produced. N.B. this is only defined if fixed_rate returns true. Generally speaking, you don't need to override this. </p>

<p>Reimplemented in <a class="el" href="classgr_1_1sync__block.html#adf288a9267d2cd9cc7d44ed265d1e0c7">gr::sync_block</a>, <a class="el" href="classgr_1_1sync__decimator.html#a71b27371abab38a2991ff61869ab5bb2">gr::sync_decimator</a>, <a class="el" href="classgr_1_1sync__interpolator.html#a20800f1c294e31f2a2ae3f04e2b3f9aa">gr::sync_interpolator</a>, <a class="el" href="classgr_1_1fec_1_1decoder.html#a82d08915e3d1a456976769a5ddf2cf3b">gr::fec::decoder</a>, and <a class="el" href="classgr_1_1fec_1_1encoder.html#a1fff2b872f82cff0e1e807868bc50bad">gr::fec::encoder</a>.</p>

</div>
</div>
<a id="abe37ff91774ef438bdfcddd0a47ec1a6" name="abe37ff91774ef438bdfcddd0a47ec1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe37ff91774ef438bdfcddd0a47ec1a6">&#9670;&#160;</a></span>fixed_rate_noutput_to_ninput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int gr::block::fixed_rate_noutput_to_ninput </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noutput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given noutput samples, return number of input samples required to produce noutput. N.B. this is only defined if fixed_rate returns true. Generally speaking, you don't need to override this. </p>

<p>Reimplemented in <a class="el" href="classgr_1_1sync__block.html#a19566d4723a1f4de45d43d08744c6a11">gr::sync_block</a>, <a class="el" href="classgr_1_1sync__decimator.html#acdd20831c3b60cd8f5ccae54cfdafb0a">gr::sync_decimator</a>, <a class="el" href="classgr_1_1sync__interpolator.html#a6d4e284dcf0a2a862ee243658156d12d">gr::sync_interpolator</a>, <a class="el" href="classgr_1_1fec_1_1decoder.html#a42fa0ed0174606141547d2a07d381283">gr::fec::decoder</a>, and <a class="el" href="classgr_1_1fec_1_1encoder.html#a85832bf2def4876666f49e7cc4f23e85">gr::fec::encoder</a>.</p>

</div>
</div>
<a id="a5bc118d94944d2ff71e378f807fb8d28" name="a5bc118d94944d2ff71e378f807fb8d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc118d94944d2ff71e378f807fb8d28">&#9670;&#160;</a></span>forecast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gr::block::forecast </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noutput_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ab02d0a829d67d39e3ac3163016d3a8be">gr_vector_int</a> &amp;&#160;</td>
          <td class="paramname"><em>ninput_items_required</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Estimate input requirements given output request. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noutput_items</td><td>number of output items to produce </td></tr>
    <tr><td class="paramname">ninput_items_required</td><td>number of input items required on each input stream</td></tr>
  </table>
  </dd>
</dl>
<p>Given a request to product <code>noutput_items</code>, estimate the number of data items required on each input stream. The estimate doesn't have to be exact, but should be close. </p>

<p>Reimplemented in <a class="el" href="classgr_1_1sync__block.html#ae4096fcd7a8c7f1baaac53350eb17443">gr::sync_block</a>, <a class="el" href="classgr_1_1sync__decimator.html#a651000d83f80bbf8dbb2cdc43c508174">gr::sync_decimator</a>, <a class="el" href="classgr_1_1sync__interpolator.html#a01614acdaf936c72dd7393998c4a5c5b">gr::sync_interpolator</a>, <a class="el" href="classgr_1_1tagged__stream__block.html#ab9f95df9bb578849bc99b398a87e8855">gr::tagged_stream_block</a>, <a class="el" href="classblock__gateway.html#a7fb652eed2f81eab3f05ed15215c91f4">block_gateway</a>, <a class="el" href="classgr_1_1fec_1_1decoder.html#a64169ea148443e97c6bfcc3c7adbe0d9">gr::fec::decoder</a>, and <a class="el" href="classgr_1_1fec_1_1encoder.html#a2e05abc331faeaee5dbb16075e1a7182">gr::fec::encoder</a>.</p>

</div>
</div>
<a id="a0a482fb96a3d7343ffdd86a21538c2e5" name="a0a482fb96a3d7343ffdd86a21538c2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a482fb96a3d7343ffdd86a21538c2e5">&#9670;&#160;</a></span>general_work()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int gr::block::general_work </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>noutput_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ab02d0a829d67d39e3ac3163016d3a8be">gr_vector_int</a> &amp;&#160;</td>
          <td class="paramname"><em>ninput_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a80a98fdffb55a4616a3078a827898dc1">gr_vector_const_void_star</a> &amp;&#160;</td>
          <td class="paramname"><em>input_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a9f99903ecddf0897227ef6e1eeca2106">gr_vector_void_star</a> &amp;&#160;</td>
          <td class="paramname"><em>output_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute output items from input items </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noutput_items</td><td>number of output items to write on each output stream </td></tr>
    <tr><td class="paramname">ninput_items</td><td>number of input items available on each input stream </td></tr>
    <tr><td class="paramname">input_items</td><td>vector of pointers to the input items, one entry per input stream </td></tr>
    <tr><td class="paramname">output_items</td><td>vector of pointers to the output items, one entry per output stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of items actually written to each output stream or WORK_CALLED_PRODUCE or WORK_DONE. It is OK to return a value less than noutput_items.</dd></dl>
<p>WORK_CALLED_PRODUCE is used where not all outputs produce the same number of items. general_work must call <a class="el" href="classgr_1_1block.html#aa5581727d057bdd8113f8b2a3fc5bd66" title="Tell the scheduler how_many_items were produced on output stream which_output.">produce()</a> for each output to indicate the number of items actually produced.</p>
<p>WORK_DONE indicates that no more data will be produced by this block.</p>
<p>general_work must call consume or consume_each to indicate how many items were consumed on each input stream. </p>

<p>Reimplemented in <a class="el" href="classgr_1_1uhd_1_1rfnoc__block.html#aa944845782e9262289a1fec106ec9b40">gr::uhd::rfnoc_block</a>, <a class="el" href="classgr_1_1sync__block.html#ab88dad1d9876d667004077ff92c33ee0">gr::sync_block</a>, <a class="el" href="classgr_1_1sync__decimator.html#a5ceeccd8aeb729ac116318b2a5151493">gr::sync_decimator</a>, <a class="el" href="classgr_1_1sync__interpolator.html#a8e7b95a19e8e083fcced26d0833a54f0">gr::sync_interpolator</a>, <a class="el" href="classgr_1_1tagged__stream__block.html#a02ecfaa830b99306dcd878537e0316f1">gr::tagged_stream_block</a>, <a class="el" href="classblock__gateway.html#afb7d9a109f4db5cb38f946d7e92f0e8d">block_gateway</a>, <a class="el" href="classgr_1_1fec_1_1async__decoder.html#ab4bb4c760107550cff3d2beaac968bde">gr::fec::async_decoder</a>, <a class="el" href="classgr_1_1fec_1_1async__encoder.html#ae547ae611e1622d44015c9b4fe5a6bd6">gr::fec::async_encoder</a>, <a class="el" href="classgr_1_1fec_1_1decoder.html#ab2563146c82e5cff9f46d7652a99ad99">gr::fec::decoder</a>, and <a class="el" href="classgr_1_1fec_1_1encoder.html#ae3991dfb5b0eb56d33d7d5254ba32141">gr::fec::encoder</a>.</p>

</div>
</div>
<a id="aa0272555827fe26a1878e53ce4be092c" name="aa0272555827fe26a1878e53ce4be092c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0272555827fe26a1878e53ce4be092c">&#9670;&#160;</a></span>get_tags_in_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::get_tags_in_range </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>which_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>abs_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>abs_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a [start,end), returns a vector of all tags in the range. </p>
<p>Range of counts is from start to end-1.</p>
<p>Tags are tuples of: (item count, source id, key, value)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector reference to return tags into </td></tr>
    <tr><td class="paramname">which_input</td><td>an integer of which input stream to pull from </td></tr>
    <tr><td class="paramname">abs_start</td><td>a uint64 count of the start of the range of interest </td></tr>
    <tr><td class="paramname">abs_end</td><td>a uint64 count of the end of the range of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83143d92b16b5bf93bf43a66a46bb60e" name="a83143d92b16b5bf93bf43a66a46bb60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83143d92b16b5bf93bf43a66a46bb60e">&#9670;&#160;</a></span>get_tags_in_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::get_tags_in_range </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>which_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>abs_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>abs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a [start,end), returns a vector of all tags in the range with a given key. </p>
<p>Range of counts is from start to end-1.</p>
<p>Tags are tuples of: (item count, source id, key, value)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector reference to return tags into </td></tr>
    <tr><td class="paramname">which_input</td><td>an integer of which input stream to pull from </td></tr>
    <tr><td class="paramname">abs_start</td><td>a uint64 count of the start of the range of interest </td></tr>
    <tr><td class="paramname">abs_end</td><td>a uint64 count of the end of the range of interest </td></tr>
    <tr><td class="paramname">key</td><td>a PMT symbol key to filter only tags of this key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf2cc497d68c4650be55765d0fe12291" name="abf2cc497d68c4650be55765d0fe12291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf2cc497d68c4650be55765d0fe12291">&#9670;&#160;</a></span>get_tags_in_window() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::get_tags_in_window </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>which_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>rel_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>rel_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets all tags within the relative window of the current call to work. </p>
<p>This operates much like get_tags_in_range but allows us to work within the current window of items. Item range is therefore within the possible range of 0 to ninput_items[whic_input].</p>
<p>Range of items counts from <code>rel_start</code> to <code>rel_end-1</code> within current window.</p>
<p>Tags are tuples of: (item count, source id, key, value)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector reference to return tags into </td></tr>
    <tr><td class="paramname">which_input</td><td>an integer of which input stream to pull from </td></tr>
    <tr><td class="paramname">rel_start</td><td>a uint64 count of the start of the range of interest </td></tr>
    <tr><td class="paramname">rel_end</td><td>a uint64 count of the end of the range of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a451b95d244e27e815eb3f9e56ea6ac32" name="a451b95d244e27e815eb3f9e56ea6ac32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a451b95d244e27e815eb3f9e56ea6ac32">&#9670;&#160;</a></span>get_tags_in_window() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::get_tags_in_window </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>which_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>rel_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>rel_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operates like <a class="el" href="classgr_1_1block.html#abf2cc497d68c4650be55765d0fe12291" title="Gets all tags within the relative window of the current call to work.">gr::block::get_tags_in_window</a> with the ability to only return tags with the specified <code>key</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>a vector reference to return tags into </td></tr>
    <tr><td class="paramname">which_input</td><td>an integer of which input stream to pull from </td></tr>
    <tr><td class="paramname">rel_start</td><td>a uint64 count of the start of the range of interest </td></tr>
    <tr><td class="paramname">rel_end</td><td>a uint64 count of the end of the range of interest </td></tr>
    <tr><td class="paramname">key</td><td>a PMT symbol key to filter only tags of this key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1bbd70747868454da06ba2049b61a18" name="aa1bbd70747868454da06ba2049b61a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bbd70747868454da06ba2049b61a18">&#9670;&#160;</a></span>history()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned gr::block::history </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assume block computes y_i = f(x_i, x_i-1, x_i-2, x_i-3...) History is the number of x_i's that are examined to produce one y_i. This comes in handy for FIR filters, where we use history to ensure that our input contains the appropriate "history" for the filter. History should be equal to the number of filter taps. First history samples (when there are no previous samples) are initialized with zeroes. </p>

</div>
</div>
<a id="a77149752323d0e1309cf43d66a31ae65" name="a77149752323d0e1309cf43d66a31ae65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77149752323d0e1309cf43d66a31ae65">&#9670;&#160;</a></span>identifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string gr::block::identifier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf6cf687db7ff69169d7fb7e3e346d65" name="abf6cf687db7ff69169d7fb7e3e346d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6cf687db7ff69169d7fb7e3e346d65">&#9670;&#160;</a></span>is_pc_rpc_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gr::block::is_pc_rpc_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if this block is already exporting perf. counters to ControlPort. </p>

</div>
</div>
<a id="a4f67d984bc126aa4d254e62464525b79" name="a4f67d984bc126aa4d254e62464525b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f67d984bc126aa4d254e62464525b79">&#9670;&#160;</a></span>is_set_max_noutput_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gr::block::is_set_max_noutput_items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ask the block if the flag is or is not set to use the internal value of max_noutput_items during a call to work. </p>

</div>
</div>
<a id="aa6323c615066d53d4d1b374900abb3f3" name="aa6323c615066d53d4d1b374900abb3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6323c615066d53d4d1b374900abb3f3">&#9670;&#160;</a></span>is_unaligned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gr::block::is_unaligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d4018d4bbe1bc19569f674003c60cc9" name="a7d4018d4bbe1bc19569f674003c60cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4018d4bbe1bc19569f674003c60cc9">&#9670;&#160;</a></span>log_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string gr::block::log_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the logger's output level. </p>

<p>Implements <a class="el" href="classgr_1_1basic__block.html#a75e374a40ecba3d1cae0e704522a3337">gr::basic_block</a>.</p>

</div>
</div>
<a id="af710a90819f19705f2d2ba1aa49d0172" name="af710a90819f19705f2d2ba1aa49d0172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af710a90819f19705f2d2ba1aa49d0172">&#9670;&#160;</a></span>max_noutput_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gr::block::max_noutput_items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the maximum number of output items this block will handle during a call to work. </p>

</div>
</div>
<a id="a5faeaab35423014dc59749d63cfe4cf1" name="a5faeaab35423014dc59749d63cfe4cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faeaab35423014dc59749d63cfe4cf1">&#9670;&#160;</a></span>max_output_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long gr::block::max_output_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns max buffer size on output port <code>i</code>. </p>

</div>
</div>
<a id="ab90ff4303cdcd140143b4f9f55a441ee" name="ab90ff4303cdcd140143b4f9f55a441ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90ff4303cdcd140143b4f9f55a441ee">&#9670;&#160;</a></span>min_noutput_items()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gr::block::min_noutput_items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the minimum number of output items this block can produce during a call to work. </p>
<p>Should be 0 for most blocks. Useful if we're dealing with packets and the block produces one packet per call to work. </p>

</div>
</div>
<a id="ac28e42e36ef843b999cca3702981ccd7" name="ac28e42e36ef843b999cca3702981ccd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28e42e36ef843b999cca3702981ccd7">&#9670;&#160;</a></span>min_output_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long gr::block::min_output_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns min buffer size on output port <code>i</code>. </p>

</div>
</div>
<a id="a594fc8f2ff2e456ed929221437696bce" name="a594fc8f2ff2e456ed929221437696bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594fc8f2ff2e456ed929221437696bce">&#9670;&#160;</a></span>mp_relative_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mpq_class &amp; gr::block::mp_relative_rate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a reference to the multiple precision rational representation of the approximate output rate / input rate </p>

</div>
</div>
<a id="a2279d1eb421203bc5b0f100a6d5dc263" name="a2279d1eb421203bc5b0f100a6d5dc263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2279d1eb421203bc5b0f100a6d5dc263">&#9670;&#160;</a></span>nitems_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gr::block::nitems_read </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>which_input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of items read on input stream which_input. </p>

</div>
</div>
<a id="a742128a481fcb9e43a3e0cd535a57f9e" name="a742128a481fcb9e43a3e0cd535a57f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742128a481fcb9e43a3e0cd535a57f9e">&#9670;&#160;</a></span>nitems_written()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gr::block::nitems_written </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>which_output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of items written on output stream which_output. </p>

</div>
</div>
<a id="a74745ea741b0aae938b003854f6043e0" name="a74745ea741b0aae938b003854f6043e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74745ea741b0aae938b003854f6043e0">&#9670;&#160;</a></span>no_pc_rpc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::no_pc_rpc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the block calls this in its constructor, it's perf. counters will not be exported. </p>

</div>
</div>
<a id="adf235647d7ec77995751de89d94a22a6" name="adf235647d7ec77995751de89d94a22a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf235647d7ec77995751de89d94a22a6">&#9670;&#160;</a></span>notify_msg_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::notify_msg_neighbors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell msg neighbors we are finished. </p>

</div>
</div>
<a id="a9a78a1ee7447a340162c719ef948b915" name="a9a78a1ee7447a340162c719ef948b915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a78a1ee7447a340162c719ef948b915">&#9670;&#160;</a></span>output_multiple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gr::block::output_multiple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3c6867e113ea236e5e07a3674783e1d" name="ad3c6867e113ea236e5e07a3674783e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c6867e113ea236e5e07a3674783e1d">&#9670;&#160;</a></span>output_multiple_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gr::block::output_multiple_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97d830331a4274ff8060fa925262afcf" name="a97d830331a4274ff8060fa925262afcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d830331a4274ff8060fa925262afcf">&#9670;&#160;</a></span>pc_input_buffers_full() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; gr::block::pc_input_buffers_full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets instantaneous fullness of all input buffers. </p>

</div>
</div>
<a id="a4989096e4edf5e8171b65e3ce663af1e" name="a4989096e4edf5e8171b65e3ce663af1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4989096e4edf5e8171b65e3ce663af1e">&#9670;&#160;</a></span>pc_input_buffers_full() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_input_buffers_full </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets instantaneous fullness of <code>which</code> input buffer. </p>

</div>
</div>
<a id="a4d364bfc03abaa13f77b515169a86cb1" name="a4d364bfc03abaa13f77b515169a86cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d364bfc03abaa13f77b515169a86cb1">&#9670;&#160;</a></span>pc_input_buffers_full_avg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; gr::block::pc_input_buffers_full_avg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets average fullness of all input buffers. </p>

</div>
</div>
<a id="a08e5deef4ebd0e6c2e11b839eaeadd9f" name="a08e5deef4ebd0e6c2e11b839eaeadd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e5deef4ebd0e6c2e11b839eaeadd9f">&#9670;&#160;</a></span>pc_input_buffers_full_avg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_input_buffers_full_avg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets average fullness of <code>which</code> input buffer. </p>

</div>
</div>
<a id="aee4a47800f4d1484e276778a2461ce37" name="aee4a47800f4d1484e276778a2461ce37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4a47800f4d1484e276778a2461ce37">&#9670;&#160;</a></span>pc_input_buffers_full_var() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; gr::block::pc_input_buffers_full_var </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets variance of fullness of all input buffers. </p>

</div>
</div>
<a id="a00723a35c6e095da35608c8438e16cdf" name="a00723a35c6e095da35608c8438e16cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00723a35c6e095da35608c8438e16cdf">&#9670;&#160;</a></span>pc_input_buffers_full_var() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_input_buffers_full_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets variance of fullness of <code>which</code> input buffer. </p>

</div>
</div>
<a id="af4a03de0d6609ca0e03b875250b7650c" name="af4a03de0d6609ca0e03b875250b7650c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a03de0d6609ca0e03b875250b7650c">&#9670;&#160;</a></span>pc_noutput_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_noutput_items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets instantaneous noutput_items performance counter. </p>

</div>
</div>
<a id="a3beb47de467a4a117b0c096f8511d3af" name="a3beb47de467a4a117b0c096f8511d3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3beb47de467a4a117b0c096f8511d3af">&#9670;&#160;</a></span>pc_noutput_items_avg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_noutput_items_avg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets average noutput_items performance counter. </p>

</div>
</div>
<a id="ae0725cd4ff4f5040a513c2a61355d434" name="ae0725cd4ff4f5040a513c2a61355d434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0725cd4ff4f5040a513c2a61355d434">&#9670;&#160;</a></span>pc_noutput_items_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_noutput_items_var </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets variance of noutput_items performance counter. </p>

</div>
</div>
<a id="a84ef5905d40b507a2230c996d8857289" name="a84ef5905d40b507a2230c996d8857289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ef5905d40b507a2230c996d8857289">&#9670;&#160;</a></span>pc_nproduced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_nproduced </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets instantaneous num items produced performance counter. </p>

</div>
</div>
<a id="ad0b4960e100a088caefa99fb39f99a02" name="ad0b4960e100a088caefa99fb39f99a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b4960e100a088caefa99fb39f99a02">&#9670;&#160;</a></span>pc_nproduced_avg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_nproduced_avg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets average num items produced performance counter. </p>

</div>
</div>
<a id="a1a506f34b8b8c3f968dc0a8cb9da0650" name="a1a506f34b8b8c3f968dc0a8cb9da0650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a506f34b8b8c3f968dc0a8cb9da0650">&#9670;&#160;</a></span>pc_nproduced_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_nproduced_var </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets variance of num items produced performance counter. </p>

</div>
</div>
<a id="abc0ec64aeeb1e51206049f7804f7774f" name="abc0ec64aeeb1e51206049f7804f7774f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0ec64aeeb1e51206049f7804f7774f">&#9670;&#160;</a></span>pc_output_buffers_full() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; gr::block::pc_output_buffers_full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets instantaneous fullness of all output buffers. </p>

</div>
</div>
<a id="ab125047ee56cf687e3475674a28d267f" name="ab125047ee56cf687e3475674a28d267f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab125047ee56cf687e3475674a28d267f">&#9670;&#160;</a></span>pc_output_buffers_full() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_output_buffers_full </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets instantaneous fullness of <code>which</code> output buffer. </p>

</div>
</div>
<a id="ad7f7e6fbb500e78493bc27b85e6c4c9f" name="ad7f7e6fbb500e78493bc27b85e6c4c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f7e6fbb500e78493bc27b85e6c4c9f">&#9670;&#160;</a></span>pc_output_buffers_full_avg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; gr::block::pc_output_buffers_full_avg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets average fullness of all output buffers. </p>

</div>
</div>
<a id="a0ed8f2224fe1d0b27e17cd66723452a8" name="a0ed8f2224fe1d0b27e17cd66723452a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed8f2224fe1d0b27e17cd66723452a8">&#9670;&#160;</a></span>pc_output_buffers_full_avg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_output_buffers_full_avg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets average fullness of <code>which</code> output buffer. </p>

</div>
</div>
<a id="a43ecae35f34a1fc99d1bcbdccb844505" name="a43ecae35f34a1fc99d1bcbdccb844505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ecae35f34a1fc99d1bcbdccb844505">&#9670;&#160;</a></span>pc_output_buffers_full_var() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; float &gt; gr::block::pc_output_buffers_full_var </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets variance of fullness of all output buffers. </p>

</div>
</div>
<a id="a2ad2a99ea794d44956d2878471e5976d" name="a2ad2a99ea794d44956d2878471e5976d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad2a99ea794d44956d2878471e5976d">&#9670;&#160;</a></span>pc_output_buffers_full_var() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_output_buffers_full_var </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets variance of fullness of <code>which</code> output buffer. </p>

</div>
</div>
<a id="a78a27917edcd3b32f10b2166f3362a68" name="a78a27917edcd3b32f10b2166f3362a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a27917edcd3b32f10b2166f3362a68">&#9670;&#160;</a></span>pc_throughput_avg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_throughput_avg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets average throughput. </p>

</div>
</div>
<a id="ae8b89079d24a3216eb1b17d75ec5b8d8" name="ae8b89079d24a3216eb1b17d75ec5b8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b89079d24a3216eb1b17d75ec5b8d8">&#9670;&#160;</a></span>pc_work_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_work_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets instantaneous clock cycles spent in work. </p>

</div>
</div>
<a id="a2df6452cef2999e1b32458a5e542f948" name="a2df6452cef2999e1b32458a5e542f948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df6452cef2999e1b32458a5e542f948">&#9670;&#160;</a></span>pc_work_time_avg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_work_time_avg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets average clock cycles spent in work. </p>

</div>
</div>
<a id="a2c9fdd36be297e4b503ccd6290663367" name="a2c9fdd36be297e4b503ccd6290663367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9fdd36be297e4b503ccd6290663367">&#9670;&#160;</a></span>pc_work_time_total()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_work_time_total </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets total clock cycles spent in work. </p>

</div>
</div>
<a id="a4918e75c4d11a0b7222c9ba250313ebc" name="a4918e75c4d11a0b7222c9ba250313ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4918e75c4d11a0b7222c9ba250313ebc">&#9670;&#160;</a></span>pc_work_time_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float gr::block::pc_work_time_var </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets average clock cycles spent in work. </p>

</div>
</div>
<a id="aa10e476b727d19dc6f95cb2326193607" name="aa10e476b727d19dc6f95cb2326193607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10e476b727d19dc6f95cb2326193607">&#9670;&#160;</a></span>processor_affinity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; gr::block::processor_affinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current processor affinity. </p>

<p>Implements <a class="el" href="classgr_1_1basic__block.html#a7507b5bcfbad500e0511ab73af4ebb7a">gr::basic_block</a>.</p>

</div>
</div>
<a id="aa5581727d057bdd8113f8b2a3fc5bd66" name="aa5581727d057bdd8113f8b2a3fc5bd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5581727d057bdd8113f8b2a3fc5bd66">&#9670;&#160;</a></span>produce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::produce </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>how_many_items</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tell the scheduler <code>how_many_items</code> were produced on output stream <code>which_output</code>. </p>
<p>This function should be used in <a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5" title="compute output items from input items">general_work()</a> to tell the scheduler the number of output items produced. If <a class="el" href="classgr_1_1block.html#aa5581727d057bdd8113f8b2a3fc5bd66" title="Tell the scheduler how_many_items were produced on output stream which_output.">produce()</a> is called in <a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5" title="compute output items from input items">general_work()</a>, <a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5" title="compute output items from input items">general_work()</a> must return <code>WORK_CALLED_PRODUCE</code>. Calling <a class="el" href="classgr_1_1block.html#aa5581727d057bdd8113f8b2a3fc5bd66" title="Tell the scheduler how_many_items were produced on output stream which_output.">produce()</a> multiple times in the same <a class="el" href="classgr_1_1block.html#a0a482fb96a3d7343ffdd86a21538c2e5" title="compute output items from input items">general_work()</a> call is safe. Every invocation of <a class="el" href="classgr_1_1block.html#aa5581727d057bdd8113f8b2a3fc5bd66" title="Tell the scheduler how_many_items were produced on output stream which_output.">produce()</a> updates the values returned by <a class="el" href="classgr_1_1block.html#a742128a481fcb9e43a3e0cd535a57f9e" title="Return the number of items written on output stream which_output.">nitems_written()</a>. </p>

</div>
</div>
<a id="a2a9a0d39af4c22733092d6556042e810" name="a2a9a0d39af4c22733092d6556042e810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a9a0d39af4c22733092d6556042e810">&#9670;&#160;</a></span>relative_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double gr::block::relative_rate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the approximate output rate / input rate </p>

</div>
</div>
<a id="a691c55aa7b05a6b316754b4833c7c08b" name="a691c55aa7b05a6b316754b4833c7c08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691c55aa7b05a6b316754b4833c7c08b">&#9670;&#160;</a></span>relative_rate_d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gr::block::relative_rate_d </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the denominator, or decimation rate, of the approximate output rate / input rate </p>

</div>
</div>
<a id="aa6a82fc4f09727a83d21a491dc355db4" name="aa6a82fc4f09727a83d21a491dc355db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a82fc4f09727a83d21a491dc355db4">&#9670;&#160;</a></span>relative_rate_i()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t gr::block::relative_rate_i </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the numerator, or interpolation rate, of the approximate output rate / input rate </p>

</div>
</div>
<a id="a94906298cd5995a94172c53dbfbc77dd" name="a94906298cd5995a94172c53dbfbc77dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94906298cd5995a94172c53dbfbc77dd">&#9670;&#160;</a></span>remove_item_tag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::remove_item_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>which_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgr_1_1tag__t.html">tag_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED. Will be removed in 3.8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which_input</td><td>an integer of which input stream to remove the tag from </td></tr>
    <tr><td class="paramname">tag</td><td>the tag object to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a461f6cc92174e83b10c3ec5336036768" name="a461f6cc92174e83b10c3ec5336036768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461f6cc92174e83b10c3ec5336036768">&#9670;&#160;</a></span>remove_item_tag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::remove_item_tag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>which_input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>abs_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> &amp;&#160;</td>
          <td class="paramname"><em>srcid</em> = <code>pmt::PMT_F</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>DEPRECATED. Will be removed in 3.8. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which_input</td><td>an integer of which input stream to remove the tag from </td></tr>
    <tr><td class="paramname">abs_offset</td><td>a uint64 number of the absolute item number associated with the tag. Can get from nitems_written. </td></tr>
    <tr><td class="paramname">key</td><td>the tag key as a PMT symbol </td></tr>
    <tr><td class="paramname">value</td><td>any PMT holding any value for the given key </td></tr>
    <tr><td class="paramname">srcid</td><td>optional source ID specifier; defaults to PMT_F</td></tr>
  </table>
  </dd>
</dl>
<p>If no such tag is found, does nothing. </p>

<p class="reference">References <a class="el" href="structgr_1_1tag__t.html#acbaaaa7b8d36f6feb8ed49dbc1228348">gr::tag_t::key</a>, <a class="el" href="structgr_1_1tag__t.html#a802cccdb470b6fb67c595f4d56ca0e7d">gr::tag_t::offset</a>, <a class="el" href="structgr_1_1tag__t.html#a89daa353004003182c8bd53869e8c653">gr::tag_t::srcid</a>, and <a class="el" href="structgr_1_1tag__t.html#aa17015fdfdc257f56cd8caa143b3fba8">gr::tag_t::value</a>.</p>

</div>
</div>
<a id="a13425cc28b7c19d8e6b004cf15df4063" name="a13425cc28b7c19d8e6b004cf15df4063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13425cc28b7c19d8e6b004cf15df4063">&#9670;&#160;</a></span>replace_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">buffer_sptr gr::block::replace_buffer </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>src_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dst_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">block_sptr&#160;</td>
          <td class="paramname"><em>block_owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the block's buffer with a new one owned by the block_owner parameter. </p>
<p>This function is used to replace the buffer on the specified output port of the block with a new buffer that is "owned" by the specified block. This function will only be called if a downstream block is using a custom buffer that is incompatible with the default buffer type created by this block. </p>

</div>
</div>
<a id="adb2d3602fe818cef1978090923667009" name="adb2d3602fe818cef1978090923667009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2d3602fe818cef1978090923667009">&#9670;&#160;</a></span>reset_perf_counters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::reset_perf_counters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the performance counters. </p>

</div>
</div>
<a id="a5fbdc43bbdf257d22298bf5e68adb875" name="a5fbdc43bbdf257d22298bf5e68adb875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbdc43bbdf257d22298bf5e68adb875">&#9670;&#160;</a></span>sample_delay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned gr::block::sample_delay </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the delay of the block. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which</td><td>Which port from which to get the sample delay. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49b49c097bffefe79f9d730539330edf" name="a49b49c097bffefe79f9d730539330edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b49c097bffefe79f9d730539330edf">&#9670;&#160;</a></span>set_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_alignment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>multiple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrains buffers to work on a set item alignment (for SIMD) </p>
<p>set_alignment_multiple causes the scheduler to ensure that the noutput_items argument passed to forecast and general_work will be an integer multiple of</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiple</td><td>The default value is 1.</td></tr>
  </table>
  </dd>
</dl>
<p>This control is similar to the output_multiple setting, except that if the number of items passed to the block is less than the output_multiple, this value is ignored and the block can produce like normal. The d_unaligned value is set to the number of items the block is off by. In the next call to general_work, the noutput_items is set to d_unaligned or less until d_unaligned==0. The buffers are now aligned again and the aligned calls can be performed again. </p>

</div>
</div>
<a id="abc9220cdf7a9972db81549e0ee1bb275" name="abc9220cdf7a9972db81549e0ee1bb275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9220cdf7a9972db81549e0ee1bb275">&#9670;&#160;</a></span>set_blkd_input_timer_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_blkd_input_timer_value </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timer_value_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED Configure the timer set when input is blocked <code>port</code>. </p>
<p>This is an advanced/experimental feature and might be removed in a future version. Calling this can affect some fundamental assumptions about the system behavior and performance.</p>
<p>In the TPB scheduler, when a block has no work to do because there is no data at it inputs, it sets a timer and tries again after a period of time. The default is 250 ms, but this can be configured differently per block when necessary</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer_value_ms</td><td>the timer value in milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a776fbf15f5280bf8da74929b4ea8bb39" name="a776fbf15f5280bf8da74929b4ea8bb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776fbf15f5280bf8da74929b4ea8bb39">&#9670;&#160;</a></span>set_detail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_detail </td>
          <td>(</td>
          <td class="paramtype">block_detail_sptr&#160;</td>
          <td class="paramname"><em>detail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa927cd4d5b8993122cf60dd556ffe62d" name="aa927cd4d5b8993122cf60dd556ffe62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa927cd4d5b8993122cf60dd556ffe62d">&#9670;&#160;</a></span>set_fixed_rate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_fixed_rate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fixed_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2dac90e45498ad53a19544c01114136" name="ac2dac90e45498ad53a19544c01114136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2dac90e45498ad53a19544c01114136">&#9670;&#160;</a></span>set_history()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_history </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>history</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cbfba0f5144d425430e4139520bb297" name="a2cbfba0f5144d425430e4139520bb297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbfba0f5144d425430e4139520bb297">&#9670;&#160;</a></span>set_inverse_relative_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_inverse_relative_rate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inverse_relative_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the approximate output rate / input rate using its reciprocal. </p>
<p>This is a convenience function to avoid numerical problems with tag propagation that calling set_relative_rate(1.0/relative_rate) might introduce. </p>

</div>
</div>
<a id="a0d33c4cc8b0131b9b8df41e3b46784b1" name="a0d33c4cc8b0131b9b8df41e3b46784b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d33c4cc8b0131b9b8df41e3b46784b1">&#9670;&#160;</a></span>set_is_unaligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_is_unaligned </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4c10f5f25c47e15f715eee574cd0951" name="ae4c10f5f25c47e15f715eee574cd0951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4c10f5f25c47e15f715eee574cd0951">&#9670;&#160;</a></span>set_log_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_log_level </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the logger's output level. </p>
<p>Sets the level of the logger. This takes a string that is translated to the standard levels and can be (case insensitive):</p>
<ul>
<li>off , notset </li>
<li>debug </li>
<li>info </li>
<li>notice </li>
<li>warn </li>
<li>error </li>
<li>crit </li>
<li>alert </li>
<li>fatal </li>
<li>emerg </li>
</ul>

<p>Implements <a class="el" href="classgr_1_1basic__block.html#a0c938f2850bf465d06e97bf9ff97165e">gr::basic_block</a>.</p>

</div>
</div>
<a id="ae2405dc2f6c84bb8e59aab56e4ce9d84" name="ae2405dc2f6c84bb8e59aab56e4ce9d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2405dc2f6c84bb8e59aab56e4ce9d84">&#9670;&#160;</a></span>set_max_noutput_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_max_noutput_items </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum number of output items this block will handle during a call to work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the maximum noutput_items this block will handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96d021628c08db3b138d3ee7c572ad90" name="a96d021628c08db3b138d3ee7c572ad90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d021628c08db3b138d3ee7c572ad90">&#9670;&#160;</a></span>set_max_output_buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_max_output_buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>max_output_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request limit on max buffer size on output port <code>port</code>. </p>
<p>This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.</p>
<p>The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested maximum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>the output port the request applies to. </td></tr>
    <tr><td class="paramname">max_output_buffer</td><td>the requested maximum output size in items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a711fb69e35fb871e9a5e41d6a1f2afb1" name="a711fb69e35fb871e9a5e41d6a1f2afb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711fb69e35fb871e9a5e41d6a1f2afb1">&#9670;&#160;</a></span>set_max_output_buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_max_output_buffer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>max_output_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request limit on max buffer size on all output ports. </p>
<p>This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.</p>
<p>The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested maximum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_output_buffer</td><td>the requested maximum output size in items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65cfc579150dc4d10c6180d3365aa9a8" name="a65cfc579150dc4d10c6180d3365aa9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cfc579150dc4d10c6180d3365aa9a8">&#9670;&#160;</a></span>set_min_noutput_items()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_min_noutput_items </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the minimum number of output items this block can produce during a call to work. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>the minimum noutput_items this block can produce. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46a03397c78096a2f1c7f1b59f225f5b" name="a46a03397c78096a2f1c7f1b59f225f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a03397c78096a2f1c7f1b59f225f5b">&#9670;&#160;</a></span>set_min_output_buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_min_output_buffer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>min_output_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request limit on min buffer size on output port <code>port</code>. </p>
<p>This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.</p>
<p>The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested minimum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>the output port the request applies to. </td></tr>
    <tr><td class="paramname">min_output_buffer</td><td>the requested minimum output size in items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d10e3f6747f91b215abe81b60a003d5" name="a9d10e3f6747f91b215abe81b60a003d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d10e3f6747f91b215abe81b60a003d5">&#9670;&#160;</a></span>set_min_output_buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_min_output_buffer </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>min_output_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request limit on the minimum buffer size on all output ports. </p>
<p>This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.</p>
<p>The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested minimum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_output_buffer</td><td>the requested minimum output size in items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63d67fd758b70c6f2d7b7d4edcec53b3" name="a63d67fd758b70c6f2d7b7d4edcec53b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d67fd758b70c6f2d7b7d4edcec53b3">&#9670;&#160;</a></span>set_output_multiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_output_multiple </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>multiple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constrain the noutput_items argument passed to forecast and general_work. </p>
<p>set_output_multiple causes the scheduler to ensure that the noutput_items argument passed to forecast and general_work will be an integer multiple of</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">multiple</td><td>The default value of output multiple is 1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00276b0a919a51d9255131c92ed91b27" name="a00276b0a919a51d9255131c92ed91b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00276b0a919a51d9255131c92ed91b27">&#9670;&#160;</a></span>set_processor_affinity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_processor_affinity </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the thread's affinity to processor core <code>n</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>a vector of ints of the core numbers available to this block. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classgr_1_1basic__block.html#a53f88988bf0d8a2174de1854f4deb6cb">gr::basic_block</a>.</p>

</div>
</div>
<a id="aff3003eea3517dd3e8d9a5297c1196b1" name="aff3003eea3517dd3e8d9a5297c1196b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3003eea3517dd3e8d9a5297c1196b1">&#9670;&#160;</a></span>set_relative_rate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_relative_rate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>relative_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the approximate output rate / input rate. </p>
<p>Provide a hint to the buffer allocator and scheduler. The default relative_rate is 1.0</p>
<p>decimators have relative_rates &lt; 1.0 interpolators have relative_rates &gt; 1.0 </p>

</div>
</div>
<a id="adf7794aa6f7ae1f9e243d6bc07687a77" name="adf7794aa6f7ae1f9e243d6bc07687a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7794aa6f7ae1f9e243d6bc07687a77">&#9670;&#160;</a></span>set_relative_rate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_relative_rate </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>interpolation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>decimation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the approximate output rate / input rate as an integer ratio. </p>
<p>Provide a hint to the buffer allocator and scheduler. The default relative_rate is interpolation / decimation = 1 / 1</p>
<p>decimators have relative_rates &lt; 1.0 interpolators have relative_rates &gt; 1.0 </p>

</div>
</div>
<a id="a476e218927e426ac88c26431cbf086cd" name="a476e218927e426ac88c26431cbf086cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476e218927e426ac88c26431cbf086cd">&#9670;&#160;</a></span>set_tag_propagation_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_tag_propagation_policy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4e">tag_propagation_policy_t</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the policy by the scheduler to determine how tags are moved downstream. </p>

</div>
</div>
<a id="a83e0fd5c4db199e6e6f2fc75cdfb5dfa" name="a83e0fd5c4db199e6e6f2fc75cdfb5dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e0fd5c4db199e6e6f2fc75cdfb5dfa">&#9670;&#160;</a></span>set_thread_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gr::block::set_thread_priority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current thread priority. </p>

</div>
</div>
<a id="a4d914fbc7814a682e25f5b2a40140d47" name="a4d914fbc7814a682e25f5b2a40140d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d914fbc7814a682e25f5b2a40140d47">&#9670;&#160;</a></span>set_unaligned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::set_unaligned </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>na</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9425064fac92607770042f472e140d7e" name="a9425064fac92607770042f472e140d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9425064fac92607770042f472e140d7e">&#9670;&#160;</a></span>setup_pc_rpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::setup_pc_rpc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up export of perf. counters to ControlPort. Only called by the scheduler. </p>

</div>
</div>
<a id="a7f58745d1374b30a7b866406dc97850f" name="a7f58745d1374b30a7b866406dc97850f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f58745d1374b30a7b866406dc97850f">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gr::block::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called to enable drivers, etc for i/o devices. </p>
<p>This allows a block to enable an associated driver to begin transferring data just before we start to execute the scheduler. The end result is that this reduces latency in the pipeline when dealing with audio devices, usrps, etc. </p>

<p>Reimplemented in <a class="el" href="classblock__gateway.html#a4692754cbe21e249f6e3288af3104fe5">block_gateway</a>, and <a class="el" href="classgr_1_1blocks_1_1probe__rate.html#a48701b9f4b0ea35baa2f9b70c26f2672">gr::blocks::probe_rate</a>.</p>

</div>
</div>
<a id="a0863bc16f7c84adf4cddf5d53124450e" name="a0863bc16f7c84adf4cddf5d53124450e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0863bc16f7c84adf4cddf5d53124450e">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gr::block::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called to disable drivers, etc for i/o devices. </p>

<p>Reimplemented in <a class="el" href="classblock__gateway.html#a886a7c11906adff32ac255ae949aee3c">block_gateway</a>, and <a class="el" href="classgr_1_1blocks_1_1probe__rate.html#a4bb3233cf82afb67ec0f8b908f608d38">gr::blocks::probe_rate</a>.</p>

</div>
</div>
<a id="a4070b0462cce39d66b0c7c90ef2153d8" name="a4070b0462cce39d66b0c7c90ef2153d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4070b0462cce39d66b0c7c90ef2153d8">&#9670;&#160;</a></span>system_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::system_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a>&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the system message handler </p>

</div>
</div>
<a id="a4892196a19ef044a0eedeaa6566893c8" name="a4892196a19ef044a0eedeaa6566893c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4892196a19ef044a0eedeaa6566893c8">&#9670;&#160;</a></span>tag_propagation_policy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgr_1_1block.html#abc40fd4d514724a5446a2b34b2352b4e">tag_propagation_policy_t</a> gr::block::tag_propagation_policy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asks for the policy used by the scheduler to moved tags downstream. </p>

</div>
</div>
<a id="a585b831aea5775730931d7fb9e6e8253" name="a585b831aea5775730931d7fb9e6e8253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585b831aea5775730931d7fb9e6e8253">&#9670;&#160;</a></span>thread_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int gr::block::thread_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current thread priority stored. </p>

</div>
</div>
<a id="a079b46fddc4241f7d5784f47a4d69893" name="a079b46fddc4241f7d5784f47a4d69893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079b46fddc4241f7d5784f47a4d69893">&#9670;&#160;</a></span>unaligned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int gr::block::unaligned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a460e8e5f15a4c5418ce3fc167c20a973" name="a460e8e5f15a4c5418ce3fc167c20a973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460e8e5f15a4c5418ce3fc167c20a973">&#9670;&#160;</a></span>unset_max_noutput_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::unset_max_noutput_items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the switch for using the max_noutput_items value of this block. </p>
<p>When <a class="el" href="classgr_1_1block.html#a4f67d984bc126aa4d254e62464525b79" title="Ask the block if the flag is or is not set to use the internal value of max_noutput_items during a ca...">is_set_max_noutput_items()</a> returns 'true', the scheduler will use the value returned by <a class="el" href="classgr_1_1block.html#af710a90819f19705f2d2ba1aa49d0172" title="Return the maximum number of output items this block will handle during a call to work.">max_noutput_items()</a> to limit the size of the number of items possible for this block's work function. If is_set_max_notput_items() returns 'false', then the scheduler ignores the internal value and uses the value set globally in the <a class="el" href="classgr_1_1top__block.html" title="Top-level hierarchical block representing a flowgraph.">top_block</a>.</p>
<p>Use this value to clear the 'is_set' flag so the scheduler will ignore this. Use the set_max_noutput_items(m) call to both set a new value for max_noutput_items and to re-enable its use in the scheduler. </p>

</div>
</div>
<a id="a84b99b697f5323c8c062ff6ac5691fc3" name="a84b99b697f5323c8c062ff6ac5691fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b99b697f5323c8c062ff6ac5691fc3">&#9670;&#160;</a></span>unset_processor_affinity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gr::block::unset_processor_affinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove processor affinity to a specific core. </p>

<p>Implements <a class="el" href="classgr_1_1basic__block.html#ac6648d85a9e1c808ba18789bf4d525ae">gr::basic_block</a>.</p>

</div>
</div>
<a id="af0c836adc464e4b05983facc66b6e401" name="af0c836adc464e4b05983facc66b6e401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c836adc464e4b05983facc66b6e401">&#9670;&#160;</a></span>update_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gr::block::update_rate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8b2991658d2d61fa34f776f557f5d508" name="a8b2991658d2d61fa34f776f557f5d508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b2991658d2d61fa34f776f557f5d508">&#9670;&#160;</a></span>d_blkd_input_timer_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int gr::block::d_blkd_input_timer_value = 250</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab740ebd7e5e88ab5ed7039db9f054db1" name="ab740ebd7e5e88ab5ed7039db9f054db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab740ebd7e5e88ab5ed7039db9f054db1">&#9670;&#160;</a></span>d_max_output_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;long&gt; gr::block::d_max_output_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c393a6daebc82ddf6844a62f1c5e8ae" name="a4c393a6daebc82ddf6844a62f1c5e8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c393a6daebc82ddf6844a62f1c5e8ae">&#9670;&#160;</a></span>d_min_output_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;long&gt; gr::block::d_min_output_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad72091916b86278b58b6d106876b3e8c" name="ad72091916b86278b58b6d106876b3e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad72091916b86278b58b6d106876b3e8c">&#9670;&#160;</a></span>d_pmt_done</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> gr::block::d_pmt_done</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PMT Symbol for "hey, we're done here" </p>

</div>
</div>
<a id="aaf5b8dd7bba021af7bd93f39453f7482" name="aaf5b8dd7bba021af7bd93f39453f7482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5b8dd7bba021af7bd93f39453f7482">&#9670;&#160;</a></span>d_setlock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacegr_1_1thread.html#a36ddd13da52283c5a38d285cd901d348">gr::thread::mutex</a> gr::block::d_setlock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used by block's setters and work functions to make setting/resetting of parameters thread-safe.</p>
<p>Used by calling <a class="el" href="namespacegr_1_1thread.html#a52544c0aefde22b130e0beabece1683b">gr::thread::scoped_lock</a> l(d_setlock); </p>

</div>
</div>
<a id="a2460fc9ff6df7f38a51dadba06b94904" name="a2460fc9ff6df7f38a51dadba06b94904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2460fc9ff6df7f38a51dadba06b94904">&#9670;&#160;</a></span>d_system_port</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> gr::block::d_system_port</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PMT Symbol of the system port, <code><a class="el" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc" title="Make pmt symbol.">pmt::mp</a>("system")</code> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="gnuradio-runtime_2include_2gnuradio_2block_8h_source.html">gnuradio-runtime/include/gnuradio/block.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacegr.html">gr</a></li><li class="navelem"><a class="el" href="classgr_1_1block.html">block</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
