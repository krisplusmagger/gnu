<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GNU Radio C++ API Reference: UHD Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/SVG"],
});
</script>
<script type="text/javascript" async="async" src="/usr/share/javascript/mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="gnuradio_logo_icon.png"/></td>
  <td id="projectalign">
   <div id="projectname">GNU Radio C++ API Reference<span id="projectnumber">&#160;v3.11.0.0git-829-g889721a8</span>
   </div>
   <div id="projectbrief">The Free &amp; Open Software Radio Ecosystem</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('page_uhd.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">UHD Interface</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="uhd_introduction"></a>
Introduction</h1>
<p>This is the GNU Radio UHD package. It is the interface to the UHD library to connect to and send and receive data between the Ettus Research, LLC product line. To use the UHD blocks, the Python namespaces is in gnuradio.uhd, which would be normally imported as:</p>
<div class="fragment"><div class="line">from <a class="code hl_namespace" href="namespacegnuradio.html">gnuradio</a> <span class="keyword">import</span> uhd</div>
<div class="ttc" id="anamespacegnuradio_html"><div class="ttname"><a href="namespacegnuradio.html">gnuradio</a></div><div class="ttdef"><b>Definition</b> sptr_magic.h:26</div></div>
</div><!-- fragment --><p>The relevant blocks are listed in the <a class="el" href="group__uhd__blk.html">UHD Interface</a> group. The most important components are the <a class="el" href="classgr_1_1uhd_1_1usrp__source.html">gr::uhd::usrp_source</a> and <a class="el" href="classgr_1_1uhd_1_1usrp__sink.html">gr::uhd::usrp_sink</a> blocks, which act as receivers/transmitters. Both are derived from <a class="el" href="classgr_1_1uhd_1_1usrp__block.html">gr::uhd::usrp_block</a>, which defines many of the shared functions between those blocks.</p>
<h1><a class="anchor" id="uhd_external_docs"></a>
External Documentation</h1>
<p>Ettus Research maintains the comprehensive documentation to the underlying UHD driver, which can be found at:</p>
<p><a href="http://files.ettus.com/manual/">http://files.ettus.com/manual/</a></p>
<p>The list of classes in the UHD Doxygen is located at:</p>
<p><a href="http://files.ettus.com/manual/annotated.html">http://files.ettus.com/manual/annotated.html</a></p>
<h1><a class="anchor" id="uhd_command_syntax"></a>
Command Syntax</h1>
<p>The UHD sink and source can be controlled by a message port. These message ports take commands, which are PMTs formatted as described in <a href="https://wiki.gnuradio.org/index.php/Message_Passing" target="_blank">Using messages as commands</a>.</p>
<p>In general, every command consists of one or more key/value pairs (either stored as a PMT pair, or a dictionary). A full list of keys is listed below.</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> command = <a class="code hl_function" href="namespacepmt.html#a7ab95721db5cbda1852f13a92eee5362">pmt::cons</a>( <span class="comment">// Make a pair</span></div>
<div class="line">    <a class="code hl_function" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a>(<span class="stringliteral">&quot;freq&quot;</span>), <span class="comment">// Key is &#39;freq&#39; =&gt; sets the frequency</span></div>
<div class="line">    <a class="code hl_function" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a>(1.1e9) <span class="comment">// Set the frequency to 1.1 GHz</span></div>
<div class="line">);</div>
<div class="line"><span class="comment">// Now pass &#39;command&#39; into the USRP block&#39;s command port</span></div>
<div class="ttc" id="anamespacepmt_html_a7ab95721db5cbda1852f13a92eee5362"><div class="ttname"><a href="namespacepmt.html#a7ab95721db5cbda1852f13a92eee5362">pmt::cons</a></div><div class="ttdeci">PMT_API pmt_t cons(const pmt_t &amp;x, const pmt_t &amp;y)</div><div class="ttdoc">Return a newly allocated pair whose car is x and whose cdr is y.</div></div>
<div class="ttc" id="anamespacepmt_html_a81bf082de5a7425eae6a6ad1eca6a4dc"><div class="ttname"><a href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a></div><div class="ttdeci">static pmt_t mp(std::string_view s)</div><div class="ttdoc">Make pmt symbol.</div><div class="ttdef"><b>Definition</b> pmt_sugar.h:25</div></div>
<div class="ttc" id="anamespacepmt_html_a94a208b58dc16675b02674c28784d88b"><div class="ttname"><a href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a></div><div class="ttdeci">std::shared_ptr&lt; pmt_base &gt; pmt_t</div><div class="ttdoc">typedef for shared pointer (transparent reference counting).</div><div class="ttdef"><b>Definition</b> pmt.h:85</div></div>
</div><!-- fragment --><p>This PMT would set the frequency to 1.1 GHz on all channels. We make use of the <a class="el" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc" title="Make pmt symbol.">pmt::mp()</a> function which automatically sets the PMT types. Assume we only want to set the frequency on channel 1 (i.e. the second channel). In this case, we must construct a dictionary: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacepmt.html#a94a208b58dc16675b02674c28784d88b">pmt::pmt_t</a> command = <a class="code hl_function" href="namespacepmt.html#aba10563e3ab43b8d52f9cb13132047cf">pmt::make_dict</a>();</div>
<div class="line">command = <a class="code hl_function" href="namespacepmt.html#a15e351077c14dcba7cb982951bbbd05b">pmt::dict_add</a>(command, <a class="code hl_function" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a>(<span class="stringliteral">&quot;freq&quot;</span>), <a class="code hl_function" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a>(1.1e9)); <span class="comment">// Specify frequency</span></div>
<div class="line">command = <a class="code hl_function" href="namespacepmt.html#a15e351077c14dcba7cb982951bbbd05b">pmt::dict_add</a>(command, <a class="code hl_function" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a>(<span class="stringliteral">&quot;chan&quot;</span>), <a class="code hl_function" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a>(1)); <span class="comment">// Specify channel</span></div>
<div class="line"><span class="comment">// Now pass &#39;command&#39; into the USRP block&#39;s command port</span></div>
<div class="ttc" id="anamespacepmt_html_a15e351077c14dcba7cb982951bbbd05b"><div class="ttname"><a href="namespacepmt.html#a15e351077c14dcba7cb982951bbbd05b">pmt::dict_add</a></div><div class="ttdeci">PMT_API pmt_t dict_add(const pmt_t &amp;dict, const pmt_t &amp;key, const pmt_t &amp;value)</div><div class="ttdoc">Return a new dictionary with key associated with value.</div></div>
<div class="ttc" id="anamespacepmt_html_aba10563e3ab43b8d52f9cb13132047cf"><div class="ttname"><a href="namespacepmt.html#aba10563e3ab43b8d52f9cb13132047cf">pmt::make_dict</a></div><div class="ttdeci">PMT_API pmt_t make_dict()</div><div class="ttdoc">Make an empty dictionary.</div></div>
</div><!-- fragment --><p>This command structure becomes more intuitive when thinking of sending the command PMT as a function call, where the key/value pairs are argument names and values, respectively. In the above example, the behaviour is the same as if calling </p><div class="fragment"><div class="line">usrp_source.set_center_freq(freq=1.1e9, chan=1)</div>
</div><!-- fragment --><p> The main difference is that we can add more properties to the same command PMT, e.g. as such: </p><div class="fragment"><div class="line"><span class="comment">// &#39;command&#39; is the same PMT as in the previous example</span></div>
<div class="line">command = <a class="code hl_function" href="namespacepmt.html#a15e351077c14dcba7cb982951bbbd05b">pmt::dict_add</a>(command, <a class="code hl_function" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a>(<span class="stringliteral">&quot;gain&quot;</span>), <a class="code hl_function" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a>(23.0)); <span class="comment">// Specify gain</span></div>
<div class="line">command = <a class="code hl_function" href="namespacepmt.html#a15e351077c14dcba7cb982951bbbd05b">pmt::dict_add</a>(command, <a class="code hl_function" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a>(<span class="stringliteral">&quot;antenna&quot;</span>), <a class="code hl_function" href="namespacepmt.html#a81bf082de5a7425eae6a6ad1eca6a4dc">pmt::mp</a>(<span class="stringliteral">&quot;TX/RX&quot;</span>)); <span class="comment">// Switch antenna</span></div>
<div class="line"><span class="comment">// Now pass &#39;command&#39; into the USRP block&#39;s command port</span></div>
</div><!-- fragment --><p> When the USRP block interprets this command PMT, all properties will be set.</p>
<h2><a class="anchor" id="uhd_command_syntax_cmds"></a>
Common command keys</h2>
<p>The following command keys are understood by both UHD Source and Sink:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Command name   </th><th class="markdownTableHeadNone">Value Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>chan</code>   </td><td class="markdownTableBodyNone">int   </td><td class="markdownTableBodyNone">Specifies a channel. If this is not given, either all channels are chosen, or channel 0, depending on the action. A value of -1 forces 'all channels', where possible.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>gain</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">Sets the Tx or Rx gain (in dB). Defaults to all channels.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>power_dbm</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">Sets the Tx or Rx power reference level (in dBm). Defaults to all channels. Works for certain devices only, and only if calibration data is available.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>freq</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">Sets the Tx or Rx frequency. Defaults to all channels. If specified without <code>lo_offset</code>, it will set the LO offset to zero.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>lo_offset</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">Sets an LO offset. Defaults to all channels. Note this does not affect the effective center frequency.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>tune</code>   </td><td class="markdownTableBodyNone">tune_request   </td><td class="markdownTableBodyNone">Like freq, but sets a full tune request (i.e. center frequency and DSP offset). Defaults to all channels.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>mtune</code>   </td><td class="markdownTableBodyNone">tune_request_t   </td><td class="markdownTableBodyNone">Like tune, but supports a full manual tune request as uhd::tune_request_t. Defaults to all channels.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>lo_freq</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">For fully manual tuning: Set the LO frequency (RF frequency). Conflicts with <code>freq</code>, <code>lo_offset</code>, and <code>tune</code>.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>dsp_freq</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">For fully manual tuning: Set the DSP frequency (CORDIC frequency). Conflicts with <code>freq</code>, <code>lo_offset</code>, and <code>tune</code>.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>direction</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">Used for timed transceiver tuning to ensure tuning order is maintained. Values other than 'TX' or 'RX' will be ignored.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>rate</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">See usrp_block::set_samp_rate(). <em>Always</em> affects all channels.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>bandwidth</code>   </td><td class="markdownTableBodyNone">double   </td><td class="markdownTableBodyNone">See usrp_block::set_bandwidth(). Defaults to all channels.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>time</code>   </td><td class="markdownTableBodyNone">timestamp   </td><td class="markdownTableBodyNone">Sets a command time. See usrp_block::set_command_time(). A value of PMT_NIL will clear the command time.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>mboard</code>   </td><td class="markdownTableBodyNone">int   </td><td class="markdownTableBodyNone">Specify mboard index, where applicable.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>antenna</code>   </td><td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone">See usrp_block::set_antenna(). Defaults to all channels.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>gpio</code>   </td><td class="markdownTableBodyNone">gpio   </td><td class="markdownTableBodyNone">PMT dictionary including bank, attr, value, mask for GPIO. See notes.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>stream_cmd</code>   </td><td class="markdownTableBodyNone">dict (stream command)   </td><td class="markdownTableBodyNone">PMT dictionary mirroring UHD's stream_cmd_t. Supported by RFNoC RX Radio. See below for details.   </td></tr>
</table>
<p>Special types:</p>
<ul>
<li>tune_request: Like a uhd::tune_request_t, but always uses POLICY_AUTO. This is a pair, composed of (target_frequency, lo_offset)</li>
<li>tune_request_t: Exact copy of uhd::tune_request_t, allowing full control. See details below. It supports fully customized tunings with all policies and integer-N tuning. The policies are strings A, N, M for automatic, none and manual tuning.</li>
<li>timestamp: A pair composed of (long full_secs, double frac_secs). Similar to uhd::time_spec_t</li>
<li>gpio: This is a PMT dictionary with four key/value pairs: bank (string), attr (string), value (double) and mask (double). The <code>gpio</code> command calls <code>set_gpio_attr</code> with the elements from the dictionary as arguments. Can optionally contain <code>mboard</code> to specify the mainboard. Defaults to <code>0</code> (first mboard).</li>
<li>Stream command dictionaryA dictionary with keys <code>stream_mode</code>, <code>num_samps</code>, <code>time_spec</code>, and <code>stream_now</code>.</li>
</ul>
<p>Further notes on command <code>mtune</code>:</p>
<p>The object is of type pmt::dict and has the same fields as uhd::tune_request_t:</p><ul>
<li><code>dsp_freq</code>: the dsp frequency as pmt double type.</li>
<li><code>dsp_freq_policy</code>: policy for DSP tuning. Should be a string "A" (automatic), "M" (manual) or "N" (none). If not set, defaults to "A".</li>
<li><code>rf_freq</code>: the rf frequency as pmt double type.</li>
<li><code>rf_freq_policy</code>: policy for RF tuning. Should be a string "A" (automatic), "M" (manual) or "N" (none). If not set, defaults to "A".</li>
<li><code>target_freq</code>: target frequency (for automatic running) as pmt double type</li>
<li><code>args</code>: string containing additional arguments, for example for integer N tuning.</li>
</ul>
<p>Further notes on command <code>stream_cmd</code>:</p>
<p>The object is of type pmt::dict and has the same fields as uhd::stream_cmd_t:</p><ul>
<li><code>stream_mode</code>: This is a string (not an enum or int) and takes the same values as the UHD Python API uses for stream modes (<code>start_cont</code>, <code>stop_cont</code>, <code>num_done</code>, and <code>num_more</code>).</li>
<li><code>stream_now</code>: Boolean</li>
<li><code>time_spec</code>: When <code>stream_now</code> is false, this is the absolute time when the stream command is executed.</li>
<li><code>num_samps</code>: When <code>stream_mode</code> is <code>num_done</code>, this is the number of samples that will be received.</li>
</ul>
<p>Example:</p>
<div class="fragment"><div class="line">tune_rx = <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.make_dict()</div>
<div class="line">tune_rx = <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.dict_add(tune_rx, <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.to_pmt(<span class="stringliteral">&#39;rf_freq&#39;</span>), <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.to_pmt(rf_freq))</div>
<div class="line">tune_rx = <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.dict_add(tune_rx, <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.to_pmt(<span class="stringliteral">&#39;rf_freq_policy&#39;</span>), <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.to_pmt(<span class="charliteral">&#39;M&#39;</span>))</div>
<div class="line">tune_rx = <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.dict_add(tune_rx, <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.to_pmt(<span class="stringliteral">&#39;dsp_freq_policy&#39;</span>), <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.to_pmt(<span class="charliteral">&#39;N&#39;</span>))</div>
<div class="line">tune_rx = <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.dict_add(tune_rx, <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.to_pmt(<span class="stringliteral">&#39;args&#39;</span>), <a class="code hl_namespace" href="namespacepmt.html">pmt</a>.to_pmt(<span class="stringliteral">&#39;mode_n=integer,int_n_step=1000e3&#39;</span>))</div>
<div class="ttc" id="anamespacepmt_html"><div class="ttname"><a href="namespacepmt.html">pmt</a></div><div class="ttdef"><b>Definition</b> pmt.h:40</div></div>
</div><!-- fragment --><p><b>Note:</b> Not all commands are affected by <code>time</code>. See the UHD manual for details on timed commands.</p>
<h2><a class="anchor" id="uhd_command_syntax_multi_vs_single"></a>
Dictionaries vs pairs</h2>
<p>Given the choices, it may be unclear if it's preferable to send multiple commands to the USRP block with a single key/value pair each, or send a single dict with all the values.</p>
<p>In general, the dictionary should be preferred. It has some distinct advantages:</p><ul>
<li>If it carries a timestamp, this timestamp is valid for all key/value pairs it may be applied to.</li>
<li>All settings will be applied at once. With multiple messages, other blocks might be sending interfering messages while the messages are being processed.</li>
</ul>
<h1><a class="anchor" id="uhd_configuring"></a>
Configuring a UHD object</h1>
<p>A typical option parser setup for a UHD device looks like</p>
<div class="fragment"><div class="line">parser = OptionParser(option_class=eng_option)</div>
<div class="line">parser.add_option(<span class="stringliteral">&quot;-a&quot;</span>, <span class="stringliteral">&quot;--args&quot;</span>, type=<span class="stringliteral">&quot;string&quot;</span>, <span class="keywordflow">default</span>=<span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">                  help=<span class="stringliteral">&quot;UHD device address args , [default=%default]&quot;</span>)</div>
<div class="line">parser.add_option(<span class="stringliteral">&quot;&quot;</span>, <span class="stringliteral">&quot;--spec&quot;</span>, type=<span class="stringliteral">&quot;string&quot;</span>, <span class="keywordflow">default</span>=None,</div>
<div class="line">                  help=<span class="stringliteral">&quot;Subdevice of UHD device where appropriate&quot;</span>)</div>
<div class="line">parser.add_option(<span class="stringliteral">&quot;-A&quot;</span>, <span class="stringliteral">&quot;--antenna&quot;</span>, type=<span class="stringliteral">&quot;string&quot;</span>, <span class="keywordflow">default</span>=None,</div>
<div class="line">                  help=<span class="stringliteral">&quot;select Rx Antenna where appropriate&quot;</span>)</div>
<div class="line">parser.add_option(<span class="stringliteral">&quot;-s&quot;</span>, <span class="stringliteral">&quot;--samp-rate&quot;</span>, type=<span class="stringliteral">&quot;eng_float&quot;</span>, <span class="keywordflow">default</span>=1e6,</div>
<div class="line">                  help=<span class="stringliteral">&quot;set sample rate (bandwidth) [default=%default]&quot;</span>)</div>
<div class="line">parser.add_option(<span class="stringliteral">&quot;-f&quot;</span>, <span class="stringliteral">&quot;--freq&quot;</span>, type=<span class="stringliteral">&quot;eng_float&quot;</span>, <span class="keywordflow">default</span>=None,</div>
<div class="line">                  help=<span class="stringliteral">&quot;set frequency to FREQ&quot;</span>, metavar=<span class="stringliteral">&quot;FREQ&quot;</span>)</div>
<div class="line">parser.add_option(<span class="stringliteral">&quot;-g&quot;</span>, <span class="stringliteral">&quot;--gain&quot;</span>, type=<span class="stringliteral">&quot;eng_float&quot;</span>, <span class="keywordflow">default</span>=None,</div>
<div class="line">                  help=<span class="stringliteral">&quot;set gain in dB (default is midpoint)&quot;</span>)</div>
</div><!-- fragment --><p>To use these options to create a UHD source object:</p>
<div class="fragment"><div class="line">stream_args = uhd.stream_args()</div>
<div class="line">self.u = uhd.usrp_source(device_addr=options.args,</div>
<div class="line">                         stream_args)</div>
<div class="line">self.u.set_samp_rate(options.samp_rate)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># if no gain was specified, use the mid-point in dB</span></div>
<div class="line"><span class="keywordflow">if</span> options.gain is None:</div>
<div class="line">    g = self.u.get_gain_range()</div>
<div class="line">    options.gain = float(g.start()+g.stop())/2</div>
<div class="line">self.u.set_gain(options.gain, 0)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Set the center frequency</span></div>
<div class="line">self.u.set_center_freq(options.freq, 0)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Set the subdevice spec</span></div>
<div class="line"><span class="keywordflow">if</span>(options.spec):</div>
<div class="line">    self.u.set_subdev_spec(options.spec, 0)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"> # Set the antenna</span></div>
<div class="line"> <span class="keywordflow">if</span>(options.antenna):</div>
<div class="line">    self.u.set_antenna(options.antenna, 0)</div>
</div><!-- fragment --><p>Frequently, your application may need a sample rate that is not supported by the UHD device. If you have extra CPU power to spare, you can easily set the sample rate you want, then ask the device what the actual sample rate set was. Then, you can easily create an arbitrary resampler to take care of the difference.</p>
<div class="fragment"><div class="line">self.u.set_samp_rate(options.samp_rate)</div>
<div class="line"> </div>
<div class="line">desired_rate = options.samp_rate</div>
<div class="line">actual_rate = self.u.get_samp_rate()</div>
<div class="line">resample = desired_rate / actual_rate</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Use the filter.pfb version and pass only the resample factor.</span></div>
<div class="line"><span class="preprocessor"># This block builds a half-band filter for you</span></div>
<div class="line"> </div>
<div class="line">self.resampler = filter.pfb.arb_resampler_ccf(resample)</div>
</div><!-- fragment --><h1><a class="anchor" id="Logging"></a>
Logging</h1>
<p>gr-uhd will emit log messages when unexpected events occur.</p>
<p>For under- and overflows, as well as command time errors, since these tend to happen in high-rate scenarios, such errors are counted for logging intervals. The first error after a time longer than the logging interval has passed is logged immediately, but subsequent log entries are accumulated.</p>
<p>The logging interval can be configured using the GNU Radio preferences framework (i.e. gnuradio.conf file), as follows:</p>
<div class="fragment"><div class="line">[uhd]</div>
<div class="line">logging_interval_ms=750</div>
</div><!-- fragment --><p>It is an integer that defaults to 750, representing the minimum number of milliseconds between logged under-, overflow events or command time errors. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
